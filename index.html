<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spring Court Runner</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#000;font-family:'Segoe UI',sans-serif;user-select:none}
canvas{display:block}

#ui-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}

#hud{position:absolute;top:20px;left:20px;right:20px;display:flex;justify-content:space-between;align-items:flex-start}
#hud-left,#hud-right{display:flex;flex-direction:column;gap:8px}
.hud-item{background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:8px 16px;color:#fff;font-size:14px;backdrop-filter:blur(6px)}
.hud-item .label{font-size:9px;text-transform:uppercase;letter-spacing:1.5px;color:#888}
.hud-item .value{font-size:22px;font-weight:700}

#beast-warning{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff3333;font-size:28px;font-weight:700;text-transform:uppercase;letter-spacing:4px;opacity:0;text-shadow:0 0 30px #ff0000}
#beast-warning.active{animation:pulse .8s ease-in-out infinite}
@keyframes pulse{0%,100%{opacity:.3;transform:translate(-50%,-50%) scale(1)}50%{opacity:1;transform:translate(-50%,-50%) scale(1.1)}}

#cycle-indicator{position:absolute;top:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.1);border-radius:20px;padding:6px 24px;color:#fff;font-size:12px;letter-spacing:3px;text-transform:uppercase;backdrop-filter:blur(6px);transition:all 1s}

#start-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(180deg,#0a1a0a 0%,#0a0a1a 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;color:#fff}
#start-screen h1{font-size:56px;font-weight:200;letter-spacing:12px;text-transform:uppercase;margin-bottom:4px;background:linear-gradient(90deg,#6f6,#8af);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
#start-screen .subtitle{font-size:18px;color:#686;letter-spacing:8px;margin-bottom:50px;font-weight:300}
#start-screen .controls{font-size:13px;color:#555;line-height:2.2;text-align:center;margin-bottom:40px}
#start-screen .controls span{color:#9d9;font-weight:600}
#start-btn{pointer-events:all;cursor:pointer;background:none;border:1px solid rgba(150,255,150,0.3);color:#afa;font-size:16px;letter-spacing:6px;text-transform:uppercase;padding:16px 60px;border-radius:30px;transition:all .3s}
#start-btn:hover{background:rgba(150,255,150,0.08);border-color:rgba(150,255,150,0.7);box-shadow:0 0 40px rgba(100,255,100,0.15)}

.story-page{display:none;flex-direction:column;align-items:center;justify-content:center;text-align:center;max-width:600px;padding:0 30px;animation:fadeInPage .6s ease}
.story-page.active{display:flex}
@keyframes fadeInPage{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
.story-page p{font-size:18px;line-height:1.9;color:#ccc;font-weight:300;letter-spacing:0.5px;margin-bottom:30px}
.story-page p span{color:#9d9;font-weight:600;background:rgba(100,255,100,0.06);padding:2px 6px;border-radius:4px}
.story-page .page-num{font-size:11px;color:#444;letter-spacing:4px;text-transform:uppercase;margin-bottom:20px}
.story-next{pointer-events:all;cursor:pointer;background:none;border:1px solid rgba(150,255,150,0.2);color:#8c8;font-size:13px;letter-spacing:4px;text-transform:uppercase;padding:10px 36px;border-radius:20px;transition:all .3s;margin-top:10px}
.story-next:hover{background:rgba(150,255,150,0.06);border-color:rgba(150,255,150,0.5)}
.story-hint{font-size:11px;color:#3a3a3a;margin-top:16px;letter-spacing:1px}

#game-over{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:100;color:#fff}
#game-over h2{font-size:42px;font-weight:200;letter-spacing:6px;margin-bottom:30px;color:#f66}
#game-over .final-score{font-size:64px;font-weight:700;background:linear-gradient(90deg,#f88,#fa8);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
#game-over .final-distance{font-size:16px;color:#666;margin-bottom:40px}
#restart-btn{pointer-events:all;cursor:pointer;background:none;border:1px solid rgba(255,100,100,0.3);color:#faa;font-size:16px;letter-spacing:4px;text-transform:uppercase;padding:14px 50px;border-radius:30px;transition:all .3s}
#restart-btn:hover{background:rgba(255,100,100,0.08);border-color:rgba(255,100,100,0.7)}

#slash-canvas{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:6}

#speed-boost{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.5);border:1px solid rgba(255,200,50,0.2);border-radius:20px;padding:4px 20px;color:#da4;font-size:11px;letter-spacing:2px;opacity:0;transition:opacity .3s;backdrop-filter:blur(4px)}
#invincible{position:absolute;bottom:60px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.5);border:1px solid rgba(100,100,255,0.3);border-radius:20px;padding:4px 20px;color:#88f;font-size:11px;letter-spacing:2px;opacity:0;transition:opacity .3s;backdrop-filter:blur(4px)}
</style>
</head>
<body>

<div id="start-screen">
  <h1>Spring Court</h1>
  <div class="subtitle">R U N N E R</div>

  <div class="story-page active" data-page="1">
    <div class="page-num">I</div>
    <p>You are a mortal, lost in the Spring Court of Prythian. The ancient forest stretches endlessly &mdash; beautiful and deadly.</p>
    <button class="story-next" onclick="advanceStory()">Continue</button>
    <div class="story-hint">Press Space or Enter</div>
  </div>

  <div class="story-page" data-page="2">
    <div class="page-num">II</div>
    <p>The Wild Hunt has found your scent. A shadow beast, born of old magic, pursues all who trespass. You must run.</p>
    <button class="story-next" onclick="advanceStory()">Continue</button>
    <div class="story-hint">Press Space or Enter</div>
  </div>

  <div class="story-page" data-page="3">
    <div class="page-num">III</div>
    <p>Weave between the forest lanes with <span>A / D</span> or <span>Arrow Keys</span>. Leap over fallen logs and brambles, or onto ancient stones with <span>W / Space</span>.</p>
    <button class="story-next" onclick="advanceStory()">Continue</button>
    <div class="story-hint">Press Space or Enter</div>
  </div>

  <div class="story-page" data-page="4">
    <div class="page-num">IV</div>
    <p>Gather ash shavings to quicken your pace. Collect iron charms to ward off fae magic. Strike down lesser fae with your ash dagger &mdash; <span>F</span>.</p>
    <button class="story-next" onclick="advanceStory()">Continue</button>
    <div class="story-hint">Press Space or Enter</div>
  </div>

  <div class="story-page" data-page="5">
    <div class="page-num">V</div>
    <p>The world shifts between Spring Court and Night Court. The beast grows faster in darkness. How far can you run?</p>
    <button id="start-btn">Enter the Forest</button>
  </div>
</div>

<div id="game-over">
  <h2>Caught by the Hunt</h2>
  <div class="final-score" id="final-score">0</div>
  <div class="final-distance" id="final-distance">0m</div>
  <button id="restart-btn">Run Again</button>
</div>

<div id="ui-overlay">
  <div id="hud">
    <div id="hud-left">
      <div class="hud-item"><div class="label">Score</div><div class="value" id="score-val">0</div></div>
      <div class="hud-item"><div class="label">Distance</div><div class="value" id="dist-val">0m</div></div>
    </div>
    <div id="hud-right">
      <div class="hud-item"><div class="label">Ash Shavings</div><div class="value" id="ash-val">0</div></div>
      <div class="hud-item"><div class="label">Iron Charms</div><div class="value" id="iron-val">0</div></div>
    </div>
  </div>
  <div id="cycle-indicator">Spring Court</div>
  <div id="beast-warning">The Hunt approaches...</div>
  <div id="speed-boost">SPEED +</div>
  <div id="invincible">IRON SHIELD</div>
</div>

<canvas id="slash-canvas"></canvas>

<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"}}</script>

<script type="module">
import * as THREE from 'three';

// ═══════════════════════════════════════════════════════════════════════════
// AUDIO ENGINE — Procedural music via Web Audio API
// ═══════════════════════════════════════════════════════════════════════════
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.started = false;
    this.dayGain = null;
    this.nightGain = null;
    this.masterGain = null;
  }

  init() {
    if (this.started) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.masterGain = this.ctx.createGain();
    this.masterGain.gain.value = 0.3;
    this.masterGain.connect(this.ctx.destination);

    // Day channel
    this.dayGain = this.ctx.createGain();
    this.dayGain.gain.value = 1;
    this.dayGain.connect(this.masterGain);

    // Night channel
    this.nightGain = this.ctx.createGain();
    this.nightGain.gain.value = 0;
    this.nightGain.connect(this.masterGain);

    this._startDayMusic();
    this._startNightMusic();
    this.started = true;
  }

  _startDayMusic() {
    // Harp-like arpeggios with chimes
    const notes = [261.6, 329.6, 392, 523.3, 392, 329.6]; // C E G C' G E
    let idx = 0;
    const play = () => {
      if (!this.ctx) return;
      const osc = this.ctx.createOscillator();
      const env = this.ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = notes[idx % notes.length];
      env.gain.setValueAtTime(0.15, this.ctx.currentTime);
      env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
      osc.connect(env);
      env.connect(this.dayGain);
      osc.start(this.ctx.currentTime);
      osc.stop(this.ctx.currentTime + 0.8);

      // Chime overtone
      const chime = this.ctx.createOscillator();
      const chimeEnv = this.ctx.createGain();
      chime.type = 'sine';
      chime.frequency.value = notes[idx % notes.length] * 3;
      chimeEnv.gain.setValueAtTime(0.03, this.ctx.currentTime);
      chimeEnv.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
      chime.connect(chimeEnv);
      chimeEnv.connect(this.dayGain);
      chime.start(this.ctx.currentTime);
      chime.stop(this.ctx.currentTime + 0.4);

      idx++;
      this._dayTimer = setTimeout(play, 500 - Math.min(100, state.speed * 50));
    };
    play();
  }

  _startNightMusic() {
    // Deep cello drone + ethereal pad
    const drone = () => {
      if (!this.ctx) return;
      const osc = this.ctx.createOscillator();
      const env = this.ctx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.value = 65.4; // C2 cello
      const filter = this.ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 400;
      filter.Q.value = 2;
      env.gain.setValueAtTime(0.08, this.ctx.currentTime);
      env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
      osc.connect(filter);
      filter.connect(env);
      env.connect(this.nightGain);
      osc.start(this.ctx.currentTime);
      osc.stop(this.ctx.currentTime + 3);

      // Ethereal pad
      const pad = this.ctx.createOscillator();
      const padEnv = this.ctx.createGain();
      pad.type = 'sine';
      const padNotes = [196, 246.9, 293.7, 349.2];
      pad.frequency.value = padNotes[Math.floor(Math.random() * padNotes.length)];
      padEnv.gain.setValueAtTime(0.04, this.ctx.currentTime);
      padEnv.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2.5);
      pad.connect(padEnv);
      padEnv.connect(this.nightGain);
      pad.start(this.ctx.currentTime);
      pad.stop(this.ctx.currentTime + 2.5);

      this._nightTimer = setTimeout(drone, 2500);
    };
    drone();
  }

  setCycle(t) {
    if (!this.started) return;
    // t: 0 = day, 1 = night
    this.dayGain.gain.linearRampToValueAtTime(1 - t, this.ctx.currentTime + 0.5);
    this.nightGain.gain.linearRampToValueAtTime(t, this.ctx.currentTime + 0.5);
  }

  playCollect(type) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = type === 'ash' ? 880 : 1200;
    osc.frequency.exponentialRampToValueAtTime(type === 'ash' ? 1320 : 1800, this.ctx.currentTime + 0.15);
    env.gain.setValueAtTime(0.2, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
    osc.connect(env);
    env.connect(this.masterGain);
    osc.start(); osc.stop(this.ctx.currentTime + 0.25);
  }

  playSlash() {
    if (!this.ctx) return;
    // White noise burst
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.15, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const env = this.ctx.createGain();
    env.gain.setValueAtTime(0.15, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 2000;
    src.connect(filter);
    filter.connect(env);
    env.connect(this.masterGain);
    src.start();
  }

  playKill() {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 600;
    osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.3);
    env.gain.setValueAtTime(0.15, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    osc.connect(env);
    env.connect(this.masterGain);
    osc.start(); osc.stop(this.ctx.currentTime + 0.3);
  }

  setHuntIntensity(v) {
    if (!this.started) return;
    this.masterGain.gain.linearRampToValueAtTime(0.3 + v * 0.15, this.ctx.currentTime + 0.3);
  }

  stop() {
    clearTimeout(this._dayTimer);
    clearTimeout(this._nightTimer);
    if (this.ctx) { this.ctx.close(); this.ctx = null; }
    this.started = false;
  }
}

const audio = new AudioEngine();

// ═══════════════════════════════════════════════════════════════════════════
// SLASH CANVAS — 2D overlay for dagger trail
// ═══════════════════════════════════════════════════════════════════════════
const slashCanvas = document.getElementById('slash-canvas');
const slashCtx = slashCanvas.getContext('2d');
let slashTrails = [];

function resizeSlash() {
  slashCanvas.width = window.innerWidth;
  slashCanvas.height = window.innerHeight;
}
resizeSlash();

function triggerSlash() {
  const cx = window.innerWidth * 0.5;
  const cy = window.innerHeight * 0.45;
  const trail = { points: [], life: 1, color: `hsl(35,80%,60%)` };
  for (let i = 0; i < 12; i++) {
    const a = -0.8 + (i / 11) * 1.6;
    const r = 80 + Math.sin(i * 0.5) * 30;
    trail.points.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r * 0.6 });
  }
  slashTrails.push(trail);
}

function updateSlashCanvas(dt) {
  slashCtx.clearRect(0, 0, slashCanvas.width, slashCanvas.height);
  for (let i = slashTrails.length - 1; i >= 0; i--) {
    const t = slashTrails[i];
    t.life -= dt * 3;
    if (t.life <= 0) { slashTrails.splice(i, 1); continue; }
    slashCtx.save();
    slashCtx.globalAlpha = t.life;
    slashCtx.strokeStyle = t.color;
    slashCtx.lineWidth = 3 * t.life;
    slashCtx.shadowColor = '#ffaa33';
    slashCtx.shadowBlur = 20 * t.life;
    slashCtx.beginPath();
    for (let j = 0; j < t.points.length; j++) {
      const p = t.points[j];
      if (j === 0) slashCtx.moveTo(p.x, p.y);
      else slashCtx.lineTo(p.x, p.y);
    }
    slashCtx.stroke();
    // Ember particles along trail
    for (let j = 0; j < t.points.length; j += 2) {
      const p = t.points[j];
      const sz = 2 * t.life * Math.random();
      slashCtx.fillStyle = `hsl(${25 + Math.random() * 20},90%,${50 + Math.random() * 30}%)`;
      slashCtx.fillRect(p.x + (Math.random() - 0.5) * 20, p.y + (Math.random() - 0.5) * 20, sz, sz);
    }
    slashCtx.restore();
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// GAME STATE
// ═══════════════════════════════════════════════════════════════════════════
const state = {
  running: false,
  speed: 0.35, baseSpeed: 0.35, maxSpeed: 0.9, speedBoost: 0,
  lane: 0, targetLane: 0, laneWidth: 2.5,
  jumping: false, jumpVel: 0, jumpForce: 0.28, gravity: 0.012, playerY: 0,
  distance: 0, score: 0, ashShavings: 0, ironCharms: 0,
  cyclePhase: 0,
  beastDistance: 80, beastClosing: false,
  attacking: false, attackTimer: 0,
  hitCooldown: 0,
  onPlatform: null,
};

// ── CACHED DOM REFS ──────────────────────────────────────────────────────
const dom = {
  scoreVal: document.getElementById('score-val'),
  distVal: document.getElementById('dist-val'),
  ashVal: document.getElementById('ash-val'),
  ironVal: document.getElementById('iron-val'),
  cycleIndicator: document.getElementById('cycle-indicator'),
  beastWarning: document.getElementById('beast-warning'),
  speedBoost: document.getElementById('speed-boost'),
  invincible: document.getElementById('invincible'),
  startScreen: document.getElementById('start-screen'),
  gameOver: document.getElementById('game-over'),
  finalScore: document.getElementById('final-score'),
  finalDistance: document.getElementById('final-distance'),
};

// ═══════════════════════════════════════════════════════════════════════════
// THREE.JS SETUP
// ═══════════════════════════════════════════════════════════════════════════
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a1a0a, 0.015);

const camera = new THREE.PerspectiveCamera(72, innerWidth / innerHeight, 0.1, 250);
camera.position.set(0, 4.5, 8);

const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: 'high-performance' });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(1);
renderer.shadowMap.enabled = false;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.4;
document.body.appendChild(renderer.domElement);

// ── LIGHTING ────────────────────────────────────────────────────────────
const ambientLight = new THREE.AmbientLight(0x3a6a3a, 0.7);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffeedd, 1.0);
dirLight.position.set(5, 15, 10);
dirLight.castShadow = false;
scene.add(dirLight);
scene.add(dirLight.target);

// Magical ambient (single scene PointLight)
const magicLight = new THREE.PointLight(0x44ff88, 0.4, 25);
scene.add(magicLight);

// ── GROUND ──────────────────────────────────────────────────────────────
const groundGeo = new THREE.PlaneGeometry(200, 500);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a2a12, roughness: 0.95 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2; ground.position.z = -200;
scene.add(ground);

// Path
const pathGeo = new THREE.PlaneGeometry(8, 500);
const pathMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.85 });
const pathMesh = new THREE.Mesh(pathGeo, pathMat);
pathMesh.rotation.x = -Math.PI / 2; pathMesh.position.y = 0.01; pathMesh.position.z = -200;
scene.add(pathMesh);

// Lane markers
for (let i = -1; i <= 1; i += 2) {
  const m = new THREE.Mesh(new THREE.PlaneGeometry(0.04, 500),
    new THREE.MeshBasicMaterial({ color: 0x444, transparent: true, opacity: 0.2 }));
  m.rotation.x = -Math.PI / 2; m.position.set(i * state.laneWidth / 2, 0.02, -200);
  scene.add(m);
}

// ── GRASS PATCHES (ground detail) ───────────────────────────────────────
const grassPatches = [];
function createGrassPatch(x, z) {
  const g = new THREE.Group();
  const blades = 3 + Math.floor(Math.random() * 3);
  const mat = new THREE.MeshStandardMaterial({ color: 0x2a6a1a, roughness: 0.9, side: THREE.DoubleSide });
  for (let i = 0; i < blades; i++) {
    const geo = new THREE.PlaneGeometry(0.05, 0.3 + Math.random() * 0.3);
    const blade = new THREE.Mesh(geo, mat);
    blade.position.set((Math.random() - 0.5) * 0.5, 0.15, (Math.random() - 0.5) * 0.5);
    blade.rotation.y = Math.random() * Math.PI;
    blade.rotation.x = (Math.random() - 0.5) * 0.3;
    blade.userData.baseRotX = blade.rotation.x;
    g.add(blade);
  }
  g.position.set(x, 0, z);
  return g;
}

// ── FLOWERS (spring court) ──────────────────────────────────────────────
const flowers = [];
function createFlower(x, z) {
  const g = new THREE.Group();
  const colors = [0xff88aa, 0x88ccff, 0xffaadd, 0xaaddff, 0xffccee];
  const color = colors[Math.floor(Math.random() * colors.length)];
  // Petals
  for (let i = 0; i < 5; i++) {
    const pGeo = new THREE.SphereGeometry(0.06, 4, 4);
    const pMat = new THREE.MeshStandardMaterial({
      color, emissive: color, emissiveIntensity: 0.4, roughness: 0.5
    });
    const petal = new THREE.Mesh(pGeo, pMat);
    const a = (i / 5) * Math.PI * 2;
    petal.position.set(Math.cos(a) * 0.08, 0.25, Math.sin(a) * 0.08);
    petal.scale.set(1, 0.5, 1);
    g.add(petal);
  }
  // Center
  const cGeo = new THREE.SphereGeometry(0.04, 4, 4);
  const cMat = new THREE.MeshStandardMaterial({ color: 0xffee44, emissive: 0xffee44, emissiveIntensity: 0.6 });
  const center = new THREE.Mesh(cGeo, cMat);
  center.position.y = 0.25;
  g.add(center);
  // Stem
  const sGeo = new THREE.CylinderGeometry(0.01, 0.015, 0.25, 4);
  const sMat = new THREE.MeshStandardMaterial({ color: 0x2a5a1a });
  const stem = new THREE.Mesh(sGeo, sMat);
  stem.position.y = 0.125;
  g.add(stem);
  g.position.set(x, 0, z);
  g.userData = { baseY: 0.25, phase: Math.random() * Math.PI * 2 };
  return g;
}

// ── MUSHROOMS (night court, bioluminescent) ─────────────────────────────
const mushrooms = [];
function createMushroom(x, z) {
  const g = new THREE.Group();
  const colors = [0x22ffaa, 0x44ddff, 0xaa88ff, 0x88ffcc];
  const color = colors[Math.floor(Math.random() * colors.length)];
  const capGeo = new THREE.SphereGeometry(0.15, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
  const capMat = new THREE.MeshStandardMaterial({
    color, emissive: color, emissiveIntensity: 0.6, roughness: 0.4,
    transparent: true, opacity: 0.9
  });
  const cap = new THREE.Mesh(capGeo, capMat);
  cap.position.y = 0.2;
  g.add(cap);
  const stemGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.2, 6);
  const stemMat = new THREE.MeshStandardMaterial({ color: 0xddddcc, roughness: 0.8 });
  g.add(new THREE.Mesh(stemGeo, stemMat));
  g.position.set(x, 0, z);
  g.userData = { glowBase: 0.3, phase: Math.random() * Math.PI * 2, color };
  return g;
}

// ── WILL-O-WISPS (night court floating lights) ──────────────────────────
const wisps = [];
function createWisp(x, z) {
  const colors = [0x44ffaa, 0x88aaff, 0xcc88ff, 0x44ddcc];
  const color = colors[Math.floor(Math.random() * colors.length)];
  const geo = new THREE.SphereGeometry(0.08, 6, 6);
  const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.7 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, 1.5 + Math.random() * 2, z);
  mesh.userData = { baseY: mesh.position.y, phase: Math.random() * Math.PI * 2, baseX: x, speed: 0.5 + Math.random() * 1.5 };
  return mesh;
}

// ── AURORA (night court sky effect) ─────────────────────────────────────
const auroraGroup = new THREE.Group();
const auroraMaterials = [];
for (let i = 0; i < 5; i++) {
  const colors = [0x22ff88, 0x8844ff, 0xccccff, 0x44ffaa, 0xaa66ff];
  const geo = new THREE.PlaneGeometry(60, 3, 30, 1);
  const mat = new THREE.MeshBasicMaterial({
    color: colors[i], transparent: true, opacity: 0, side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set((i - 2) * 8, 30 + i * 2, -40);
  mesh.rotation.x = -0.3;
  mesh.userData = { phase: i * 1.2 };
  auroraGroup.add(mesh);
  auroraMaterials.push(mat);
  // Animate vertices for wave
  const posAttr = geo.attributes.position;
  mesh.userData.origPositions = new Float32Array(posAttr.array);
}
scene.add(auroraGroup);

// ── SUN RAYS (day court, volumetric-like beams) ─────────────────────────
const sunRays = [];
for (let i = 0; i < 8; i++) {
  const geo = new THREE.PlaneGeometry(0.3, 15);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffeedd, transparent: true, opacity: 0.04, side: THREE.DoubleSide
  });
  const ray = new THREE.Mesh(geo, mat);
  ray.position.set(-8 + i * 2.5 + Math.random() * 2, 8, -20 + Math.random() * 10);
  ray.rotation.z = (Math.random() - 0.5) * 0.3;
  ray.rotation.y = Math.random() * 0.5;
  scene.add(ray);
  sunRays.push(ray);
}

// ── GROUND PARTICLES (dust motes) ───────────────────────────────────────
const dustGeo = new THREE.BufferGeometry();
const dustCount = 60;
const dustPositions = new Float32Array(dustCount * 3);
const dustSizes = new Float32Array(dustCount);
for (let i = 0; i < dustCount; i++) {
  dustPositions[i * 3] = (Math.random() - 0.5) * 30;
  dustPositions[i * 3 + 1] = Math.random() * 5;
  dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
  dustSizes[i] = 1 + Math.random() * 2;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
dustGeo.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));
const dustMat = new THREE.PointsMaterial({
  color: 0xffeedd, size: 0.05, transparent: true, opacity: 0.3,
  blending: THREE.AdditiveBlending, depthWrite: false
});
const dustParticles = new THREE.Points(dustGeo, dustMat);
scene.add(dustParticles);

// ── PLAYER ──────────────────────────────────────────────────────────────
const playerGroup = new THREE.Group();

const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcc8866, roughness: 0.6 });
const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 0.8, 8, 12), bodyMat);
body.position.y = 1.0; playerGroup.add(body);

const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12),
  new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.5 }));
head.position.y = 1.75; playerGroup.add(head);

const hair = new THREE.Mesh(new THREE.ConeGeometry(0.28, 0.6, 8),
  new THREE.MeshStandardMaterial({ color: 0x553322, roughness: 0.8 }));
hair.position.set(0, 1.85, 0.1); hair.rotation.x = 0.3; playerGroup.add(hair);

const cloak = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.2, 8),
  new THREE.MeshStandardMaterial({ color: 0x2a3a2a, roughness: 0.85 }));
cloak.position.set(0, 0.8, 0.15); playerGroup.add(cloak);

// Dagger
const daggerGroup = new THREE.Group();
const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.5, 0.05),
  new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.9, roughness: 0.1, emissive: 0x443300, emissiveIntensity: 0 }));
blade.position.y = 0.25; daggerGroup.add(blade);
const hilt = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.1),
  new THREE.MeshStandardMaterial({ color: 0x5a3a1a }));
daggerGroup.add(hilt);
daggerGroup.position.set(0.55, 1.3, -0.2);
daggerGroup.visible = false;
playerGroup.add(daggerGroup);

// Legs
const legMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8 });
const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8), legMat);
leftLeg.position.set(-0.15, 0.3, 0); playerGroup.add(leftLeg);
const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8), legMat);
rightLeg.position.set(0.15, 0.3, 0); playerGroup.add(rightLeg);

scene.add(playerGroup);

// ── BEAST ───────────────────────────────────────────────────────────────
const beastGroup = new THREE.Group();
const beastBody = new THREE.Mesh(
  new THREE.SphereGeometry(1.2, 8, 8),
  new THREE.MeshStandardMaterial({ color: 0x1a0505, roughness: 0.4, emissive: 0x330000, emissiveIntensity: 0.4 })
);
beastBody.scale.set(1, 0.7, 1.5); beastBody.position.y = 1.2; beastGroup.add(beastBody);
// Tendrils
for (let i = 0; i < 6; i++) {
  const t = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.02, 1.5, 4),
    new THREE.MeshStandardMaterial({ color: 0x1a0505, emissive: 0x220000, emissiveIntensity: 0.3 }));
  t.position.set((Math.random() - 0.5) * 1.5, 0.5, 0.5 + Math.random());
  t.rotation.x = 0.5 + Math.random() * 0.5;
  t.rotation.z = (Math.random() - 0.5) * 0.8;
  beastGroup.add(t);
}
// Eyes
for (let s of [-1, 1]) {
  const eye = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8),
    new THREE.MeshBasicMaterial({ color: 0xff2200 }));
  eye.position.set(s * 0.4, 1.5, -1.2);
  beastGroup.add(eye);
}
const beastLight = new THREE.PointLight(0xff2200, 0.5, 20);
beastLight.position.y = 2; beastGroup.add(beastLight);
beastGroup.position.set(0, 0, 80);
scene.add(beastGroup);

// ── OBJECT POOLS ────────────────────────────────────────────────────────
const trees = [], obstacles = [], collectibles = [], fairies = [], particles = [];
const envObjects = []; // flowers, mushrooms, wisps, grass

function createTree() {
  const g = new THREE.Group();
  const h = 4 + Math.random() * 5;
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.3, h, 6),
    new THREE.MeshStandardMaterial({ color: 0x3a2510, roughness: 0.95 }));
  trunk.position.y = h / 2; g.add(trunk);
  // Multiple canopy layers
  for (let j = 0; j < 2 + Math.floor(Math.random() * 2); j++) {
    const r = 1.0 + Math.random() * 1.0;
    const canopy = new THREE.Mesh(new THREE.SphereGeometry(r, 7, 7),
      new THREE.MeshStandardMaterial({ color: 0x1a5a1a, roughness: 0.85 }));
    canopy.position.set((Math.random() - 0.5) * 0.8, h + j * 0.8, (Math.random() - 0.5) * 0.8);
    g.add(canopy);
  }
  return g;
}

function createObstacle(type) {
  const g = new THREE.Group();
  if (type === 'bramble') {
    const mat = new THREE.MeshStandardMaterial({ color: 0x3a2a15, roughness: 0.9 });
    for (let i = 0; i < 6; i++) {
      const vine = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.07, 1.0 + Math.random() * 0.4, 5), mat);
      vine.position.set((Math.random() - 0.5) * 1.2, 0.5, (Math.random() - 0.5) * 0.6);
      vine.rotation.set((Math.random() - 0.5) * 0.5, 0, (Math.random() - 0.5) * 0.8);
      g.add(vine);
    }
    const thornMat = new THREE.MeshStandardMaterial({ color: 0x2a6a2a, emissive: 0x0a3a0a, emissiveIntensity: 0.3 });
    for (let i = 0; i < 10; i++) {
      const thorn = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.15, 4), thornMat);
      thorn.position.set((Math.random() - 0.5) * 1.5, Math.random() * 1.0, (Math.random() - 0.5) * 0.5);
      thorn.rotation.z = Math.random() * Math.PI;
      g.add(thorn);
    }
    g.userData = { type: 'bramble', hitbox: { w: 1.5, h: 1.2 } };
  } else {
    const log = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 3.5, 8),
      new THREE.MeshStandardMaterial({ color: 0x3a2510, roughness: 0.95 }));
    log.rotation.z = Math.PI / 2; log.position.y = 0.35; g.add(log);
    for (let i = 0; i < 4; i++) {
      const moss = new THREE.Mesh(new THREE.SphereGeometry(0.12 + Math.random() * 0.1, 5, 5),
        new THREE.MeshStandardMaterial({ color: 0x2a6a2a, roughness: 0.9 }));
      moss.position.set((Math.random() - 0.5) * 2.5, 0.5, (Math.random() - 0.5) * 0.3);
      g.add(moss);
    }
    g.userData = { type: 'log', hitbox: { w: 2.5, h: 0.8 } };
  } else if (type === 'rock') {
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x6a6a60, roughness: 0.85 });
    const rock = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.7, 0.5, 8), rockMat);
    rock.position.y = 0.25; g.add(rock);
    // Moss accents on top
    const mossMat = new THREE.MeshStandardMaterial({ color: 0x3a7a2a, roughness: 0.9 });
    for (let i = 0; i < 3; i++) {
      const moss = new THREE.Mesh(new THREE.SphereGeometry(0.08 + Math.random() * 0.06, 5, 5), mossMat);
      const a = Math.random() * Math.PI * 2;
      moss.position.set(Math.cos(a) * 0.3, 0.5, Math.sin(a) * 0.3);
      g.add(moss);
    }
    g.userData = { type: 'rock', hitbox: { w: 1.2, h: 0.5 }, jumpable: true };
  }
  return g;
}

function createCollectible(type) {
  const g = new THREE.Group();
  if (type === 'ash') {
    const mesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.22, 0),
      new THREE.MeshStandardMaterial({ color: 0xddaa44, emissive: 0xcc8822, emissiveIntensity: 0.6, metalness: 0.4, roughness: 0.3 }));
    g.add(mesh);
    g.userData = { type: 'ash', rotSpeed: 2 + Math.random() };
  } else {
    const mesh = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.06, 8, 16),
      new THREE.MeshStandardMaterial({ color: 0x8888cc, emissive: 0x4444aa, emissiveIntensity: 0.5, metalness: 0.9, roughness: 0.1 }));
    g.add(mesh);
    g.userData = { type: 'iron', rotSpeed: 3 + Math.random() };
  }
  g.position.y = 1.0;
  return g;
}

function createFairy() {
  const g = new THREE.Group();
  const faeColor = state.cyclePhase > 0.5 ? 0x8844ff : 0x6633aa;
  const bodyMesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8),
    new THREE.MeshStandardMaterial({ color: faeColor, emissive: faeColor, emissiveIntensity: 0.5, roughness: 0.3 }));
  g.add(bodyMesh);
  for (let s of [-1, 1]) {
    const wing = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.3),
      new THREE.MeshBasicMaterial({ color: 0xbb88ff, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
    wing.position.set(s * 0.35, 0.1, 0);
    wing.rotation.y = s * 0.5;
    g.add(wing);
  }
  // Pulsing eyes
  for (let s of [-1, 1]) {
    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.07, 6, 6),
      new THREE.MeshBasicMaterial({ color: 0xffff00 }));
    eye.position.set(s * 0.12, 0.08, -0.25);
    g.add(eye);
  }
  g.position.y = 1.5;
  g.userData = { type: 'fairy', alive: true, hitbox: { w: 0.8, h: 1.0 },
    bobPhase: Math.random() * Math.PI * 2 };
  return g;
}

function spawnParticle(pos, color, count = 1) {
  for (let i = 0; i < count; i++) {
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.05, 4, 4),
      new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 }));
    mesh.position.copy(pos);
    mesh.userData = {
      vel: new THREE.Vector3((Math.random() - 0.5) * 0.2, Math.random() * 0.2, (Math.random() - 0.5) * 0.15),
      life: 1
    };
    scene.add(mesh);
    particles.push(mesh);
  }
}

// ── SPAWN MANAGEMENT ────────────────────────────────────────────────────
let nextObsZ = -30, nextColZ = -20, nextFairyZ = -50, nextEnvZ = -5;

function spawnObjects() {
  const farZ = playerGroup.position.z - 100;

  while (nextObsZ > farZ) {
    const r = Math.random();
    const obs = createObstacle(r < 0.2 ? 'rock' : r < 0.6 ? 'bramble' : 'log');
    obs.position.set(Math.floor(Math.random() * 3 - 1) * state.laneWidth, 0, nextObsZ);
    scene.add(obs); obstacles.push(obs);
    nextObsZ -= 12 + Math.random() * 15;
  }
  while (nextColZ > farZ) {
    const col = createCollectible(Math.random() > 0.3 ? 'ash' : 'iron');
    col.position.set(Math.floor(Math.random() * 3 - 1) * state.laneWidth, 1.0, nextColZ);
    scene.add(col); collectibles.push(col);
    nextColZ -= 6 + Math.random() * 10;
  }
  while (nextFairyZ > farZ) {
    const f = createFairy();
    f.position.set(Math.floor(Math.random() * 3 - 1) * state.laneWidth, 1.5, nextFairyZ);
    scene.add(f); fairies.push(f);
    nextFairyZ -= 25 + Math.random() * 35;
  }
  // Environment (flowers, mushrooms, wisps, grass)
  while (nextEnvZ > farZ) {
    for (let s of [-1, 1]) {
      const x = s * (4.5 + Math.random() * 12);
      // Flowers (spring) - reduced density
      if (Math.random() > 0.65) {
        const f = createFlower(x, nextEnvZ); scene.add(f); envObjects.push(f); flowers.push(f);
      }
      // Mushrooms (night) - reduced density
      if (Math.random() > 0.8) {
        const m = createMushroom(x + (Math.random() - 0.5) * 3, nextEnvZ - Math.random() * 3);
        scene.add(m); envObjects.push(m); mushrooms.push(m);
      }
      // Wisps - reduced density
      if (Math.random() > 0.9) {
        const w = createWisp(x, nextEnvZ - Math.random() * 5);
        scene.add(w); envObjects.push(w); wisps.push(w);
      }
      // Grass
      if (Math.random() > 0.3) {
        const gr = createGrassPatch(x + (Math.random() - 0.5) * 5, nextEnvZ - Math.random() * 3);
        scene.add(gr); envObjects.push(gr); grassPatches.push(gr);
      }
    }
    // Trees
    for (let s of [-1, 1]) {
      if (Math.random() > 0.2) {
        const tree = createTree();
        tree.position.set(s * (5 + Math.random() * 18), 0, nextEnvZ);
        scene.add(tree); trees.push(tree);
      }
    }
    nextEnvZ -= 4 + Math.random() * 4;
  }
}

function cleanup() {
  const behindZ = playerGroup.position.z + 10;
  for (const arr of [obstacles, collectibles, fairies, envObjects, trees, flowers, mushrooms, wisps, grassPatches]) {
    while (arr.length > 0 && arr[0].position.z > behindZ) {
      scene.remove(arr.shift());
    }
  }
}

// ── INPUT ───────────────────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (!state.running) return;
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.targetLane = Math.max(-1, state.targetLane - 1);
  if (e.code === 'ArrowRight' || e.code === 'KeyD') state.targetLane = Math.min(1, state.targetLane + 1);
  if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') doJump();
  if (e.code === 'KeyF') doAttack();
});
// Touch/click handlers removed for performance (keyboard-only controls)

function doJump() { if (!state.jumping || state.onPlatform) { state.jumping = true; state.jumpVel = state.jumpForce; state.onPlatform = null; } }
function doAttack() {
  if (!state.attacking) {
    state.attacking = true; state.attackTimer = 0.3;
    daggerGroup.visible = true;
    blade.material.emissiveIntensity = 1.0;
    triggerSlash();
    audio.playSlash();
  }
}

// ── DAY / NIGHT CYCLE ───────────────────────────────────────────────────
function updateCycle() {
  const dist = Math.abs(state.distance);
  const cycleLen = 1000;
  const pos = (dist % cycleLen) / cycleLen;
  let t;
  if (pos < 0.4) t = 0;
  else if (pos < 0.5) t = (pos - 0.4) / 0.1;
  else if (pos < 0.9) t = 1;
  else t = 1 - (pos - 0.9) / 0.1;
  state.cyclePhase = t;

  // Sky/fog — night is brighter and more magical (not dark)
  const dayFog = new THREE.Color(0x0a1a0a);
  const nightFog = new THREE.Color(0x0a0a1a);
  scene.fog.color.lerpColors(dayFog, nightFog, t);
  scene.fog.density = 0.015 - t * 0.003; // less fog at night for better visibility

  // Ambient — night is brighter, magical blue/purple
  const dayAmb = new THREE.Color(0x3a6a3a);
  const nightAmb = new THREE.Color(0x3a3a6a);
  ambientLight.color.lerpColors(dayAmb, nightAmb, t);
  ambientLight.intensity = 0.7 + t * 0.3;

  // Directional light — moonlight at night
  dirLight.color.lerpColors(new THREE.Color(0xffeedd), new THREE.Color(0xaabbff), t);
  dirLight.intensity = 1.0 - t * 0.2;

  renderer.toneMappingExposure = 1.4 - t * 0.2;

  // Sun rays
  for (const ray of sunRays) ray.material.opacity = (1 - t) * 0.04;

  // Aurora
  for (let i = 0; i < auroraMaterials.length; i++) {
    auroraMaterials[i].opacity = t * 0.12;
    const mesh = auroraGroup.children[i];
    const orig = mesh.userData.origPositions;
    const posAttr = mesh.geometry.attributes.position;
    const time = Date.now() * 0.001;
    for (let j = 0; j < posAttr.count; j++) {
      posAttr.array[j * 3 + 1] = orig[j * 3 + 1] + Math.sin(time * 0.5 + j * 0.3 + mesh.userData.phase) * 2;
    }
    posAttr.needsUpdate = true;
  }
  auroraGroup.position.z = state.distance - 40;

  // Mushroom emissive glow (night)
  for (const m of mushrooms) {
    const cap = m.children[0];
    if (cap && cap.material) cap.material.emissiveIntensity = 0.2 + t * 0.6;
  }
  // Wisps (brighter at night)
  for (const w of wisps) {
    w.material.opacity = 0.2 + t * 0.6;
  }

  // Ground color shift
  groundMat.color.lerpColors(new THREE.Color(0x1a2a12), new THREE.Color(0x10101a), t);
  pathMat.color.lerpColors(new THREE.Color(0x2a1a0a), new THREE.Color(0x1a1020), t);

  // Dust particles color
  dustMat.color.lerpColors(new THREE.Color(0xffeedd), new THREE.Color(0x8888ff), t);
  dustMat.opacity = 0.2 + t * 0.15;

  if (t < 0.3) { dom.cycleIndicator.textContent = 'SPRING COURT'; dom.cycleIndicator.style.color = '#8f8'; dom.cycleIndicator.style.borderColor = 'rgba(100,255,100,0.2)'; }
  else if (t > 0.7) { dom.cycleIndicator.textContent = 'NIGHT COURT'; dom.cycleIndicator.style.color = '#aaf'; dom.cycleIndicator.style.borderColor = 'rgba(150,150,255,0.3)'; }
  else { dom.cycleIndicator.textContent = 'TWILIGHT'; dom.cycleIndicator.style.color = '#a8a'; dom.cycleIndicator.style.borderColor = 'rgba(170,130,170,0.2)'; }

  audio.setCycle(t);
}

// ── COLLISIONS ──────────────────────────────────────────────────────────
function checkCollisions() {
  const px = playerGroup.position.x, pz = playerGroup.position.z, py = state.playerY;

  for (const obs of obstacles) {
    const dz = Math.abs(obs.position.z - pz), dx = Math.abs(obs.position.x - px);
    if (dz < 1.0 && dx < obs.userData.hitbox.w / 2 + 0.3) {
      if (obs.userData.jumpable && py >= obs.userData.hitbox.h - 0.1 && state.jumpVel <= 0) {
        // Land on top of rock
        state.playerY = obs.userData.hitbox.h;
        state.jumping = false;
        state.jumpVel = 0;
        state.onPlatform = obs;
        state.score += 15;
      } else if (py < obs.userData.hitbox.h) {
        if (state.hitCooldown <= 0) { gameOver(); return; }
      }
    }
  }
  for (const fairy of fairies) {
    if (!fairy.userData.alive) continue;
    const dz = Math.abs(fairy.position.z - pz), dx = Math.abs(fairy.position.x - px);
    if (dz < 1.2 && dx < 0.8) {
      if (state.attacking) {
        fairy.userData.alive = false;
        state.score += 50;
        spawnParticle(fairy.position.clone(), 0xaa66ff, 5);
        audio.playKill();
        scene.remove(fairy);
      } else if (state.hitCooldown <= 0) { gameOver(); return; }
    }
  }
  for (let i = collectibles.length - 1; i >= 0; i--) {
    const col = collectibles[i];
    const dz = Math.abs(col.position.z - pz), dx = Math.abs(col.position.x - px);
    if (dz < 1.2 && dx < 0.8 && Math.abs(py + 1 - col.position.y) < 1.2) {
      if (col.userData.type === 'ash') {
        state.ashShavings++;
        state.score += 10;
        state.speedBoost = Math.min(0.3, state.speedBoost + 0.015);
        spawnParticle(col.position.clone(), 0xddaa44, 6);
        dom.speedBoost.style.opacity = '1';
        dom.speedBoost.textContent = `SPEED +${Math.round(state.speedBoost * 100)}%`;
        setTimeout(() => dom.speedBoost.style.opacity = '0', 1500);
      } else {
        state.ironCharms++;
        state.score += 25;
        state.hitCooldown = 3;
        // Iron also slows beast
        state.beastDistance = Math.min(80, state.beastDistance + 8);
        spawnParticle(col.position.clone(), 0x6666ff, 6);
        dom.invincible.style.opacity = '1';
        setTimeout(() => dom.invincible.style.opacity = '0', 3000);
      }
      audio.playCollect(col.userData.type);
      scene.remove(col);
      collectibles.splice(i, 1);
    }
  }
}

// ── GAME OVER ───────────────────────────────────────────────────────────
function gameOver() {
  state.running = false;
  const finalScore = state.score + Math.floor(Math.abs(state.distance)) + state.ashShavings * 5 + state.ironCharms * 10;
  dom.finalScore.textContent = finalScore.toLocaleString();
  dom.finalDistance.textContent = Math.floor(Math.abs(state.distance)) + 'm';
  dom.gameOver.style.display = 'flex';
}

// ── UPDATE ──────────────────────────────────────────────────────────────
const clock = new THREE.Clock();
let runAnim = 0;

function update() {
  const dt = Math.min(clock.getDelta(), 0.05);
  updateSlashCanvas(dt);
  if (!state.running) return;

  // Speed
  const baseNow = state.baseSpeed + Math.abs(state.distance) * 0.00008;
  state.speed = Math.min(state.maxSpeed, baseNow * (1 + state.speedBoost));

  // Forward
  state.distance -= state.speed;
  playerGroup.position.z = state.distance;

  // Lane
  playerGroup.position.x += (state.targetLane * state.laneWidth - playerGroup.position.x) * 0.15;

  // Jump
  if (state.jumping) {
    state.jumpVel -= state.gravity;
    state.playerY += state.jumpVel;
    if (state.playerY <= 0) { state.playerY = 0; state.jumping = false; }
  }
  // Platform tracking — fall off rock once player passes it
  if (state.onPlatform) {
    if (state.onPlatform.position.z > playerGroup.position.z + 1.0) {
      state.onPlatform = null;
      state.jumping = true;
      state.jumpVel = 0;
    }
  }
  playerGroup.position.y = state.playerY;

  // Run animation
  runAnim += dt * state.speed * 25;
  leftLeg.rotation.x = Math.sin(runAnim) * 0.6;
  rightLeg.rotation.x = Math.sin(runAnim + Math.PI) * 0.6;
  body.rotation.x = Math.sin(runAnim * 2) * 0.03;
  cloak.rotation.x = 0.1 + Math.sin(runAnim) * 0.06;
  hair.rotation.x = 0.3 + Math.sin(runAnim) * 0.04;

  // Attack
  if (state.attacking) {
    state.attackTimer -= dt;
    daggerGroup.rotation.z = Math.sin(state.attackTimer * 30) * 1.5;
    blade.material.emissiveIntensity = state.attackTimer * 3;
    if (state.attackTimer <= 0) { state.attacking = false; daggerGroup.visible = false; blade.material.emissiveIntensity = 0; }
  }

  // Invincibility
  if (state.hitCooldown > 0) {
    state.hitCooldown -= dt;
    body.material.emissive.setHex(0x222266);
    body.material.emissiveIntensity = 0.3 + Math.sin(Date.now() * 0.02) * 0.2;
  } else {
    body.material.emissive.setHex(0x000000);
    body.material.emissiveIntensity = 0;
  }

  state.score += Math.floor(state.speed * 2);

  // Camera
  camera.position.x += (playerGroup.position.x * 0.3 - camera.position.x) * 0.08;
  camera.position.z = state.distance + 8;
  camera.position.y = 4.5 + state.playerY * 0.3;
  camera.lookAt(playerGroup.position.x * 0.5, 1.5, state.distance - 10);

  // Move ground
  ground.position.z = state.distance - 200;
  pathMesh.position.z = state.distance - 200;

  // Lights follow
  magicLight.position.set(playerGroup.position.x, 3, state.distance - 5);
  dirLight.position.set(playerGroup.position.x + 5, 15, state.distance + 10);
  dirLight.target.position.set(playerGroup.position.x, 0, state.distance);

  // Dust follows
  dustParticles.position.z = state.distance;
  const dPos = dustGeo.attributes.position.array;
  for (let i = 0; i < dustCount; i++) {
    dPos[i * 3 + 1] += Math.sin(Date.now() * 0.001 + i) * 0.003;
    if (dPos[i * 3 + 1] > 5) dPos[i * 3 + 1] = 0;
  }
  dustGeo.attributes.position.needsUpdate = true;

  // Beast
  if (Math.abs(state.distance) > 100) {
    const beastSpd = state.speed * (0.85 + state.cyclePhase * 0.2);
    state.beastDistance -= (state.speed - beastSpd) * 0.25;
    state.beastDistance = Math.max(6, state.beastDistance);
    state.beastClosing = state.beastDistance < 25;
  }
  beastGroup.position.z = state.distance + state.beastDistance;
  beastGroup.position.x += (playerGroup.position.x - beastGroup.position.x) * 0.015;
  beastBody.rotation.y = Math.sin(Date.now() * 0.003) * 0.2;
  beastLight.intensity = 0.5 + (state.beastClosing ? Math.sin(Date.now() * 0.01) * 0.8 : 0);
  audio.setHuntIntensity(state.beastClosing ? Math.max(0, 1 - state.beastDistance / 25) : 0);

  dom.beastWarning.classList.toggle('active', state.beastClosing);
  if (state.beastDistance <= 6) { gameOver(); return; }

  // Collectible animation
  for (const col of collectibles) {
    col.rotation.y += dt * (col.userData.rotSpeed || 2);
    col.position.y = 1.0 + Math.sin(Date.now() * 0.003 + col.position.z) * 0.2;
  }
  // Fairy animation
  for (const f of fairies) {
    if (f.userData.alive) {
      f.position.y = 1.5 + Math.sin(Date.now() * 0.004 + f.userData.bobPhase) * 0.4;
      f.rotation.y += dt * 2;
    }
  }
  // Wisps float
  for (const w of wisps) {
    w.position.y = w.userData.baseY + Math.sin(Date.now() * 0.002 * w.userData.speed + w.userData.phase) * 0.5;
    w.position.x = w.userData.baseX + Math.sin(Date.now() * 0.001 + w.userData.phase) * 1.5;
  }
  // Grass wind
  for (const gp of grassPatches) {
    for (const blade of gp.children) {
      blade.rotation.x = blade.userData.baseRotX + Math.sin(Date.now() * 0.002 + gp.position.z * 0.1) * 0.15;
    }
  }
  // Flower bob (skip per-frame filter)
  // Flowers animate via their group position, not individual petals

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.userData.life -= dt * 2.5;
    p.position.add(p.userData.vel);
    p.userData.vel.y -= 0.004;
    p.material.opacity = Math.max(0, p.userData.life);
    p.scale.setScalar(p.userData.life);
    if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
  }

  updateCycle();
  spawnObjects();
  cleanup();
  checkCollisions();

  // HUD
  dom.scoreVal.textContent = state.score.toLocaleString();
  dom.distVal.textContent = Math.floor(Math.abs(state.distance)) + 'm';
  dom.ashVal.textContent = state.ashShavings;
  dom.ironVal.textContent = state.ironCharms;
}

// ── RENDER LOOP ─────────────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}
animate();

// ── START / RESTART ─────────────────────────────────────────────────────
function startGame() {
  audio.init();
  Object.assign(state, {
    running: true, speed: state.baseSpeed, distance: 0, score: 0,
    ashShavings: 0, ironCharms: 0, speedBoost: 0,
    lane: 0, targetLane: 0, jumping: false, jumpVel: 0, playerY: 0,
    beastDistance: 80, beastClosing: false, attacking: false, hitCooldown: 0, cyclePhase: 0, onPlatform: null,
  });
  playerGroup.position.set(0, 0, 0);
  beastGroup.position.set(0, 0, 80);
  nextObsZ = -30; nextColZ = -20; nextFairyZ = -50; nextEnvZ = -5;
  for (const arr of [obstacles, collectibles, fairies, particles, envObjects, trees, flowers, mushrooms, wisps, grassPatches]) {
    while (arr.length) scene.remove(arr.pop());
  }
  slashTrails = [];
  dom.startScreen.style.display = 'none';
  dom.gameOver.style.display = 'none';
  dom.speedBoost.style.opacity = '0';
  dom.invincible.style.opacity = '0';
  clock.getDelta();
}

// ── STORY PAGES ──────────────────────────────────────────────────────
let storyPage = 1;
const storyPages = document.querySelectorAll('.story-page');
const totalStoryPages = storyPages.length;

window.advanceStory = function() {
  if (storyPage >= totalStoryPages) return;
  storyPages[storyPage - 1].classList.remove('active');
  storyPage++;
  storyPages[storyPage - 1].classList.add('active');
};

document.addEventListener('keydown', e => {
  if (dom.startScreen.style.display === 'none' || state.running) return;
  if (dom.gameOver.style.display === 'flex') return;
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    if (storyPage < totalStoryPages) {
      advanceStory();
    } else {
      startGame();
    }
  }
});

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  resizeSlash();
});
</script>
</body>
</html>
