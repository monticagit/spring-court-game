<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spring Court Runner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }

#ui-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 10;
}

#hud {
  position: absolute; top: 20px; left: 20px; right: 20px;
  display: flex; justify-content: space-between; align-items: flex-start;
}
#hud-left, #hud-right { display: flex; flex-direction: column; gap: 8px; }
.hud-item {
  background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px; padding: 8px 16px; color: #fff; font-size: 14px;
  backdrop-filter: blur(4px);
}
.hud-item .label { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: #aaa; }
.hud-item .value { font-size: 22px; font-weight: 700; }

#beast-warning {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #ff3333; font-size: 28px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 4px; opacity: 0; text-shadow: 0 0 20px #ff0000;
  animation: none;
}
#beast-warning.active {
  animation: pulse 0.8s ease-in-out infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
  50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
}

#cycle-indicator {
  position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
  background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.15);
  border-radius: 20px; padding: 6px 20px; color: #fff; font-size: 13px;
  letter-spacing: 2px; text-transform: uppercase;
  backdrop-filter: blur(4px); transition: all 1s;
}

/* Start screen */
#start-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: linear-gradient(180deg, #0a1a0a 0%, #1a0a2a 100%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100; color: #fff;
}
#start-screen h1 {
  font-size: 52px; font-weight: 300; letter-spacing: 8px;
  text-transform: uppercase; margin-bottom: 8px;
  text-shadow: 0 0 40px rgba(100,200,100,0.5);
}
#start-screen .subtitle {
  font-size: 16px; color: #8a8; letter-spacing: 4px; margin-bottom: 60px;
}
#start-screen .controls {
  font-size: 13px; color: #777; line-height: 2; text-align: center; margin-bottom: 40px;
}
#start-screen .controls span { color: #ada; font-weight: 600; }
#start-btn {
  pointer-events: all; cursor: pointer;
  background: none; border: 1px solid rgba(150,255,150,0.4);
  color: #afa; font-size: 18px; letter-spacing: 6px; text-transform: uppercase;
  padding: 16px 60px; border-radius: 4px; transition: all 0.3s;
}
#start-btn:hover {
  background: rgba(150,255,150,0.1); border-color: rgba(150,255,150,0.8);
  box-shadow: 0 0 30px rgba(100,255,100,0.2);
}

/* Game over */
#game-over {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.85); display: none; flex-direction: column;
  align-items: center; justify-content: center; z-index: 100; color: #fff;
}
#game-over h2 { font-size: 42px; font-weight: 300; letter-spacing: 6px; margin-bottom: 30px; color: #f66; }
#game-over .final-score { font-size: 60px; font-weight: 700; margin-bottom: 8px; }
#game-over .final-distance { font-size: 16px; color: #888; margin-bottom: 40px; }
#restart-btn {
  pointer-events: all; cursor: pointer;
  background: none; border: 1px solid rgba(255,100,100,0.4);
  color: #faa; font-size: 16px; letter-spacing: 4px; text-transform: uppercase;
  padding: 14px 50px; border-radius: 4px; transition: all 0.3s;
}
#restart-btn:hover {
  background: rgba(255,100,100,0.1); border-color: rgba(255,100,100,0.8);
}

/* Attack flash */
#attack-flash {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: radial-gradient(circle, rgba(255,200,50,0.3) 0%, transparent 70%);
  opacity: 0; pointer-events: none; z-index: 5; transition: opacity 0.1s;
}
</style>
</head>
<body>

<div id="start-screen">
  <h1>Spring Court</h1>
  <div class="subtitle">R U N N E R</div>
  <div class="controls">
    <span>A / D</span> or <span>← →</span> — Switch Lanes<br>
    <span>W</span> or <span>↑</span> or <span>SPACE</span> — Jump<br>
    <span>F</span> or <span>CLICK</span> — Ash Dagger Attack<br>
    <span>SWIPE</span> on mobile
  </div>
  <button id="start-btn">Enter the Forest</button>
</div>

<div id="game-over">
  <h2>Caught by the Hunt</h2>
  <div class="final-score" id="final-score">0</div>
  <div class="final-distance" id="final-distance">0m</div>
  <button id="restart-btn">Run Again</button>
</div>

<div id="ui-overlay">
  <div id="hud">
    <div id="hud-left">
      <div class="hud-item"><div class="label">Score</div><div class="value" id="score-val">0</div></div>
      <div class="hud-item"><div class="label">Distance</div><div class="value" id="dist-val">0m</div></div>
    </div>
    <div id="hud-right">
      <div class="hud-item"><div class="label">Ash Shavings</div><div class="value" id="ash-val">0</div></div>
      <div class="hud-item"><div class="label">Iron Charms</div><div class="value" id="iron-val">0</div></div>
    </div>
  </div>
  <div id="cycle-indicator">Spring Court</div>
  <div id="beast-warning">The Hunt approaches...</div>
</div>

<div id="attack-flash"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// ── GAME STATE ──────────────────────────────────────────────────────────────
const state = {
  running: false,
  speed: 0.35,
  baseSpeed: 0.35,
  maxSpeed: 0.9,
  lane: 0,           // -1, 0, 1
  targetLane: 0,
  laneWidth: 2.5,
  jumping: false,
  jumpVel: 0,
  jumpForce: 0.28,
  gravity: 0.012,
  playerY: 0,
  distance: 0,
  score: 0,
  ashShavings: 0,
  ironCharms: 0,
  cyclePhase: 0,     // 0 = spring, 1 = transition, 2 = night court
  beastDistance: 80,
  beastClosing: false,
  attacking: false,
  attackTimer: 0,
  hitCooldown: 0,
  highScore: parseInt(localStorage.getItem('spr_highscore') || '0'),
};

// ── THREE.JS SETUP ──────────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a1a0a, 0.018);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 4, 8);
camera.lookAt(0, 1.5, -10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

// ── COLORS ──────────────────────────────────────────────────────────────────
const SPRING = {
  sky: new THREE.Color(0x1a3a1a),
  fog: new THREE.Color(0x0a1a0a),
  ambient: new THREE.Color(0x2a4a2a),
  ground: 0x1a2a15,
  path: 0x2a1a0a,
  tree: 0x2a1a0a,
  leaves: 0x1a5a1a,
};
const NIGHT = {
  sky: new THREE.Color(0x0a0a1a),
  fog: new THREE.Color(0x05050f),
  ambient: new THREE.Color(0x1a1a3a),
  ground: 0x0a0a15,
  path: 0x15101a,
  tree: 0x1a1020,
  leaves: 0x2a1a4a,
};

// ── LIGHTING ────────────────────────────────────────────────────────────────
const ambientLight = new THREE.AmbientLight(SPRING.ambient, 0.6);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffeedd, 0.8);
dirLight.position.set(5, 15, 10);
dirLight.castShadow = true;
dirLight.shadow.camera.near = 0.1;
dirLight.shadow.camera.far = 60;
dirLight.shadow.camera.left = -15;
dirLight.shadow.camera.right = 15;
dirLight.shadow.camera.top = 15;
dirLight.shadow.camera.bottom = -15;
dirLight.shadow.mapSize.set(1024, 1024);
scene.add(dirLight);

// Magical glow
const pointLight = new THREE.PointLight(0x44ff88, 0.5, 30);
pointLight.position.set(0, 3, -5);
scene.add(pointLight);

// ── GROUND ──────────────────────────────────────────────────────────────────
const groundGeo = new THREE.PlaneGeometry(200, 400);
const groundMat = new THREE.MeshStandardMaterial({ color: SPRING.ground, roughness: 0.9 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.z = -150;
ground.receiveShadow = true;
scene.add(ground);

// Path / road
const pathGeo = new THREE.PlaneGeometry(8, 400);
const pathMat = new THREE.MeshStandardMaterial({ color: SPRING.path, roughness: 0.8 });
const path = new THREE.Mesh(pathGeo, pathMat);
path.rotation.x = -Math.PI / 2;
path.position.y = 0.01;
path.position.z = -150;
path.receiveShadow = true;
scene.add(path);

// Lane markers
for (let i = -1; i <= 1; i += 2) {
  const markerGeo = new THREE.PlaneGeometry(0.05, 400);
  const markerMat = new THREE.MeshBasicMaterial({ color: 0x3a3a3a, transparent: true, opacity: 0.3 });
  const marker = new THREE.Mesh(markerGeo, markerMat);
  marker.rotation.x = -Math.PI / 2;
  marker.position.set(i * state.laneWidth / 2, 0.02, -150);
  scene.add(marker);
}

// ── PLAYER ──────────────────────────────────────────────────────────────────
const playerGroup = new THREE.Group();

// Body
const bodyGeo = new THREE.CapsuleGeometry(0.3, 0.8, 8, 12);
const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcc8866, roughness: 0.7 });
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.position.y = 1.0;
body.castShadow = true;
playerGroup.add(body);

// Head
const headGeo = new THREE.SphereGeometry(0.25, 12, 12);
const headMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.6 });
const head = new THREE.Mesh(headGeo, headMat);
head.position.y = 1.75;
head.castShadow = true;
playerGroup.add(head);

// Hair
const hairGeo = new THREE.ConeGeometry(0.28, 0.6, 8);
const hairMat = new THREE.MeshStandardMaterial({ color: 0x553322, roughness: 0.8 });
const hair = new THREE.Mesh(hairGeo, hairMat);
hair.position.set(0, 1.85, 0.1);
hair.rotation.x = 0.3;
playerGroup.add(hair);

// Cloak
const cloakGeo = new THREE.ConeGeometry(0.5, 1.2, 8);
const cloakMat = new THREE.MeshStandardMaterial({ color: 0x2a3a2a, roughness: 0.9 });
const cloak = new THREE.Mesh(cloakGeo, cloakMat);
cloak.position.set(0, 0.8, 0.15);
cloak.rotation.x = 0.1;
playerGroup.add(cloak);

// Dagger (shown during attack)
const daggerGroup = new THREE.Group();
const bladeGeo = new THREE.BoxGeometry(0.05, 0.4, 0.05);
const bladeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 });
const blade = new THREE.Mesh(bladeGeo, bladeMat);
blade.position.y = 0.2;
daggerGroup.add(blade);
const hiltGeo = new THREE.BoxGeometry(0.08, 0.12, 0.08);
const hiltMat = new THREE.MeshStandardMaterial({ color: 0x5a3a1a });
const hilt = new THREE.Mesh(hiltGeo, hiltMat);
daggerGroup.add(hilt);
daggerGroup.position.set(0.5, 1.3, -0.2);
daggerGroup.visible = false;
playerGroup.add(daggerGroup);

// Legs (simple animation cylinders)
const legMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8 });
const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8), legMat);
leftLeg.position.set(-0.15, 0.3, 0);
playerGroup.add(leftLeg);
const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8), legMat);
rightLeg.position.set(0.15, 0.3, 0);
playerGroup.add(rightLeg);

playerGroup.position.set(0, 0, 0);
scene.add(playerGroup);

// ── BEAST (THE HUNT) ────────────────────────────────────────────────────────
const beastGroup = new THREE.Group();
const beastBodyGeo = new THREE.SphereGeometry(1.2, 8, 8);
const beastBodyMat = new THREE.MeshStandardMaterial({ color: 0x1a0a0a, roughness: 0.5, emissive: 0x220000, emissiveIntensity: 0.3 });
const beastBody = new THREE.Mesh(beastBodyGeo, beastBodyMat);
beastBody.scale.set(1, 0.7, 1.5);
beastBody.position.y = 1.2;
beastGroup.add(beastBody);

// Eyes
for (let side of [-1, 1]) {
  const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
  const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff2200 });
  const eye = new THREE.Mesh(eyeGeo, eyeMat);
  eye.position.set(side * 0.4, 1.5, -1.0);
  beastGroup.add(eye);
}

beastGroup.position.set(0, 0, state.beastDistance);
scene.add(beastGroup);

// Beast point light
const beastLight = new THREE.PointLight(0xff2200, 0.5, 15);
beastLight.position.set(0, 2, 0);
beastGroup.add(beastLight);

// ── OBJECT POOLS ────────────────────────────────────────────────────────────
const trees = [];
const obstacles = [];
const collectibles = [];
const fairies = [];
const particles = [];

function createTree() {
  const g = new THREE.Group();
  // Trunk
  const trunkH = 3 + Math.random() * 4;
  const trunkGeo = new THREE.CylinderGeometry(0.15, 0.25, trunkH, 6);
  const trunkMat = new THREE.MeshStandardMaterial({ color: SPRING.tree, roughness: 0.9 });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = trunkH / 2;
  trunk.castShadow = true;
  g.add(trunk);
  // Canopy
  const canopyGeo = new THREE.SphereGeometry(1.2 + Math.random() * 0.8, 6, 6);
  const canopyMat = new THREE.MeshStandardMaterial({ color: SPRING.leaves, roughness: 0.8 });
  const canopy = new THREE.Mesh(canopyGeo, canopyMat);
  canopy.position.y = trunkH + 0.5;
  canopy.castShadow = true;
  g.add(canopy);
  g.userData = { canopyMat, trunkMat };
  return g;
}

function createObstacle(type) {
  const g = new THREE.Group();
  if (type === 'bramble') {
    // Thorny bramble (ground obstacle — jump over)
    const mat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9 });
    for (let i = 0; i < 5; i++) {
      const vineGeo = new THREE.CylinderGeometry(0.05, 0.08, 1.2, 5);
      const vine = new THREE.Mesh(vineGeo, mat);
      vine.position.set((Math.random() - 0.5) * 1.2, 0.6, (Math.random() - 0.5) * 0.5);
      vine.rotation.z = (Math.random() - 0.5) * 0.8;
      vine.rotation.x = (Math.random() - 0.5) * 0.4;
      g.add(vine);
    }
    // Thorns
    const thornMat = new THREE.MeshStandardMaterial({ color: 0x1a4a1a, emissive: 0x0a2a0a, emissiveIntensity: 0.3 });
    for (let i = 0; i < 8; i++) {
      const thornGeo = new THREE.ConeGeometry(0.04, 0.15, 4);
      const thorn = new THREE.Mesh(thornGeo, thornMat);
      thorn.position.set((Math.random() - 0.5) * 1.5, Math.random() * 1.0, (Math.random() - 0.5) * 0.5);
      thorn.rotation.z = Math.random() * Math.PI;
      g.add(thorn);
    }
    g.userData = { type: 'bramble', hitbox: { w: 1.5, h: 1.2 } };
  } else {
    // Fallen log (ground obstacle — jump over)
    const logGeo = new THREE.CylinderGeometry(0.3, 0.35, 3, 8);
    const logMat = new THREE.MeshStandardMaterial({ color: 0x3a2510, roughness: 0.95 });
    const log = new THREE.Mesh(logGeo, logMat);
    log.rotation.z = Math.PI / 2;
    log.position.y = 0.35;
    log.castShadow = true;
    g.add(log);
    // Moss
    const mossGeo = new THREE.SphereGeometry(0.15, 6, 6);
    const mossMat = new THREE.MeshStandardMaterial({ color: 0x2a5a2a, roughness: 0.9 });
    for (let i = 0; i < 3; i++) {
      const moss = new THREE.Mesh(mossGeo, mossMat);
      moss.position.set((Math.random() - 0.5) * 2, 0.5, (Math.random() - 0.5) * 0.3);
      moss.scale.setScalar(0.5 + Math.random() * 0.5);
      g.add(moss);
    }
    g.userData = { type: 'log', hitbox: { w: 2.5, h: 0.8 } };
  }
  return g;
}

function createCollectible(type) {
  const g = new THREE.Group();
  if (type === 'ash') {
    // Ash-wood shaving — golden shard
    const geo = new THREE.OctahedronGeometry(0.2, 0);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xddaa44, emissive: 0xaa7722, emissiveIntensity: 0.5,
      metalness: 0.3, roughness: 0.4
    });
    const mesh = new THREE.Mesh(geo, mat);
    g.add(mesh);
    // Glow
    const glowGeo = new THREE.SphereGeometry(0.35, 8, 8);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xddaa44, transparent: true, opacity: 0.15 });
    g.add(new THREE.Mesh(glowGeo, glowMat));
    g.userData = { type: 'ash', rotSpeed: 2 + Math.random() };
  } else {
    // Iron charm — silvery ring
    const geo = new THREE.TorusGeometry(0.2, 0.06, 8, 16);
    const mat = new THREE.MeshStandardMaterial({
      color: 0x8888aa, emissive: 0x4444aa, emissiveIntensity: 0.4,
      metalness: 0.8, roughness: 0.2
    });
    const mesh = new THREE.Mesh(geo, mat);
    g.add(mesh);
    const glowGeo = new THREE.SphereGeometry(0.35, 8, 8);
    const glowMat = new THREE.MeshBasicMaterial({ color: 0x6666ff, transparent: true, opacity: 0.12 });
    g.add(new THREE.Mesh(glowGeo, glowMat));
    g.userData = { type: 'iron', rotSpeed: 3 + Math.random() };
  }
  g.position.y = 1.0;
  return g;
}

function createFairy() {
  const g = new THREE.Group();
  // Body
  const bodyGeo = new THREE.SphereGeometry(0.3, 8, 8);
  const bodyMat = new THREE.MeshStandardMaterial({
    color: 0x6633aa, emissive: 0x4422aa, emissiveIntensity: 0.5,
    roughness: 0.4
  });
  g.add(new THREE.Mesh(bodyGeo, bodyMat));
  // Wings
  for (let side of [-1, 1]) {
    const wingGeo = new THREE.PlaneGeometry(0.5, 0.3);
    const wingMat = new THREE.MeshBasicMaterial({
      color: 0xaa88ff, transparent: true, opacity: 0.5, side: THREE.DoubleSide
    });
    const wing = new THREE.Mesh(wingGeo, wingMat);
    wing.position.set(side * 0.35, 0.1, 0);
    wing.rotation.y = side * 0.5;
    g.add(wing);
  }
  // Eyes
  for (let side of [-1, 1]) {
    const eyeGeo = new THREE.SphereGeometry(0.06, 6, 6);
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const eye = new THREE.Mesh(eyeGeo, eyeMat);
    eye.position.set(side * 0.12, 0.08, -0.25);
    g.add(eye);
  }
  // Glow light
  const fLight = new THREE.PointLight(0x8844ff, 0.4, 6);
  g.add(fLight);
  g.position.y = 1.5;
  g.userData = { type: 'fairy', alive: true, hitbox: { w: 0.8, h: 1.0 }, bobPhase: Math.random() * Math.PI * 2 };
  return g;
}

function spawnParticle(pos, color) {
  const geo = new THREE.SphereGeometry(0.06, 4, 4);
  const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  mesh.userData = {
    vel: new THREE.Vector3((Math.random() - 0.5) * 0.15, Math.random() * 0.15, (Math.random() - 0.5) * 0.1),
    life: 1.0
  };
  scene.add(mesh);
  particles.push(mesh);
}

// ── SPAWN SCENERY ───────────────────────────────────────────────────────────
function populateInitialTrees() {
  for (let z = -5; z > -200; z -= 3 + Math.random() * 4) {
    for (let side of [-1, 1]) {
      const tree = createTree();
      tree.position.set(side * (5 + Math.random() * 15), 0, z);
      scene.add(tree);
      trees.push(tree);
    }
  }
}
populateInitialTrees();

let nextObstacleZ = -30;
let nextCollectibleZ = -20;
let nextFairyZ = -50;

function spawnObjects() {
  const farZ = playerGroup.position.z - 120;

  // Obstacles
  while (nextObstacleZ > farZ) {
    const type = Math.random() > 0.5 ? 'bramble' : 'log';
    const obs = createObstacle(type);
    const lane = Math.floor(Math.random() * 3) - 1;
    obs.position.set(lane * state.laneWidth, 0, nextObstacleZ);
    scene.add(obs);
    obstacles.push(obs);
    nextObstacleZ -= 12 + Math.random() * 15;
  }

  // Collectibles
  while (nextCollectibleZ > farZ) {
    const type = Math.random() > 0.3 ? 'ash' : 'iron';
    const col = createCollectible(type);
    const lane = Math.floor(Math.random() * 3) - 1;
    col.position.set(lane * state.laneWidth, 1.0, nextCollectibleZ);
    scene.add(col);
    collectibles.push(col);
    nextCollectibleZ -= 6 + Math.random() * 10;
  }

  // Fairies
  while (nextFairyZ > farZ) {
    const fairy = createFairy();
    const lane = Math.floor(Math.random() * 3) - 1;
    fairy.position.set(lane * state.laneWidth, 1.5, nextFairyZ);
    scene.add(fairy);
    fairies.push(fairy);
    nextFairyZ -= 25 + Math.random() * 35;
  }

  // More trees
  const treeFarZ = playerGroup.position.z - 200;
  while (trees.length > 0 && trees[0].position.z > playerGroup.position.z + 10) {
    scene.remove(trees.shift());
  }
  const lastTreeZ = trees.length > 0 ? trees[trees.length - 1].position.z : playerGroup.position.z;
  for (let z = lastTreeZ - 5; z > treeFarZ; z -= 3 + Math.random() * 4) {
    for (let side of [-1, 1]) {
      if (Math.random() > 0.3) {
        const tree = createTree();
        tree.position.set(side * (5 + Math.random() * 15), 0, z);
        scene.add(tree);
        trees.push(tree);
      }
    }
  }
}

// ── CLEANUP ─────────────────────────────────────────────────────────────────
function cleanupBehind() {
  const behindZ = playerGroup.position.z + 15;
  for (const arr of [obstacles, collectibles, fairies]) {
    while (arr.length > 0 && arr[0].position.z > behindZ) {
      scene.remove(arr.shift());
    }
  }
}

// ── INPUT ───────────────────────────────────────────────────────────────────
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (!state.running) return;
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') moveLeft();
  if (e.code === 'ArrowRight' || e.code === 'KeyD') moveRight();
  if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') jump();
  if (e.code === 'KeyF') attack();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });
document.addEventListener('click', e => {
  if (state.running) attack();
});

// Touch / swipe
let touchStartX = 0, touchStartY = 0;
document.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});
document.addEventListener('touchend', e => {
  if (!state.running) return;
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx < -40) moveLeft();
    else if (dx > 40) moveRight();
  } else {
    if (dy < -40) jump();
    else if (dy > 40) attack();
  }
});

function moveLeft() { state.targetLane = Math.max(-1, state.targetLane - 1); }
function moveRight() { state.targetLane = Math.min(1, state.targetLane + 1); }
function jump() {
  if (!state.jumping) {
    state.jumping = true;
    state.jumpVel = state.jumpForce;
  }
}
function attack() {
  if (!state.attacking) {
    state.attacking = true;
    state.attackTimer = 0.3;
    daggerGroup.visible = true;
    document.getElementById('attack-flash').style.opacity = '0.6';
    setTimeout(() => { document.getElementById('attack-flash').style.opacity = '0'; }, 100);
  }
}

// ── DAY / NIGHT CYCLE ───────────────────────────────────────────────────────
function updateCycle() {
  const dist = Math.abs(state.distance);
  // Transition starts at 500m, full night by 1000m, then oscillates
  const cycleLen = 1000;
  const pos = (dist % cycleLen) / cycleLen;
  let t;
  if (pos < 0.4) t = 0;                               // spring
  else if (pos < 0.5) t = (pos - 0.4) / 0.1;          // transition to night
  else if (pos < 0.9) t = 1;                           // night
  else t = 1 - (pos - 0.9) / 0.1;                     // transition to spring

  state.cyclePhase = t;

  // Interpolate colors
  scene.fog.color.lerpColors(SPRING.fog, NIGHT.fog, t);
  ambientLight.color.lerpColors(SPRING.ambient, NIGHT.ambient, t);
  renderer.toneMappingExposure = 1.2 - t * 0.5;

  const indicator = document.getElementById('cycle-indicator');
  if (t < 0.3) { indicator.textContent = 'SPRING COURT'; indicator.style.color = '#8f8'; }
  else if (t > 0.7) { indicator.textContent = 'NIGHT COURT'; indicator.style.color = '#88f'; }
  else { indicator.textContent = 'TWILIGHT'; indicator.style.color = '#a8a'; }
}

// ── COLLISION ───────────────────────────────────────────────────────────────
function checkCollisions() {
  const px = playerGroup.position.x;
  const pz = playerGroup.position.z;
  const py = state.playerY;

  // Obstacles
  for (const obs of obstacles) {
    const dz = Math.abs(obs.position.z - pz);
    const dx = Math.abs(obs.position.x - px);
    const hb = obs.userData.hitbox;
    if (dz < 1.0 && dx < hb.w / 2 + 0.3 && py < hb.h) {
      if (state.hitCooldown <= 0) {
        gameOver();
        return;
      }
    }
  }

  // Fairies (collision = damage unless attacking)
  for (const fairy of fairies) {
    if (!fairy.userData.alive) continue;
    const dz = Math.abs(fairy.position.z - pz);
    const dx = Math.abs(fairy.position.x - px);
    if (dz < 1.2 && dx < 0.8) {
      if (state.attacking) {
        // Kill fairy
        fairy.userData.alive = false;
        state.score += 50;
        for (let i = 0; i < 8; i++) spawnParticle(fairy.position.clone(), 0xaa66ff);
        scene.remove(fairy);
      } else if (state.hitCooldown <= 0) {
        gameOver();
        return;
      }
    }
  }

  // Collectibles
  for (let i = collectibles.length - 1; i >= 0; i--) {
    const col = collectibles[i];
    const dz = Math.abs(col.position.z - pz);
    const dx = Math.abs(col.position.x - px);
    if (dz < 1.2 && dx < 0.8 && Math.abs(py + 1.0 - col.position.y) < 1.0) {
      if (col.userData.type === 'ash') {
        state.ashShavings++;
        state.score += 10;
        state.speed = Math.min(state.maxSpeed, state.speed + 0.005);
        for (let j = 0; j < 5; j++) spawnParticle(col.position.clone(), 0xddaa44);
      } else {
        state.ironCharms++;
        state.score += 25;
        state.hitCooldown = 3;  // invincibility frames
        for (let j = 0; j < 5; j++) spawnParticle(col.position.clone(), 0x6666ff);
      }
      scene.remove(col);
      collectibles.splice(i, 1);
    }
  }
}

// ── GAME OVER ───────────────────────────────────────────────────────────────
function gameOver() {
  state.running = false;
  document.getElementById('final-score').textContent = state.score.toLocaleString();
  document.getElementById('final-distance').textContent = Math.floor(Math.abs(state.distance)) + 'm';
  document.getElementById('game-over').style.display = 'flex';
  if (state.score > state.highScore) {
    state.highScore = state.score;
    localStorage.setItem('spr_highscore', state.score.toString());
  }
}

// ── UPDATE ──────────────────────────────────────────────────────────────────
const clock = new THREE.Clock();
let runAnim = 0;

function update() {
  const dt = Math.min(clock.getDelta(), 0.05);
  if (!state.running) return;

  // Speed gradually increases
  state.speed = Math.min(state.maxSpeed, state.baseSpeed + Math.abs(state.distance) * 0.00008);

  // Move forward
  state.distance -= state.speed;
  playerGroup.position.z = state.distance;

  // Lane movement (smooth)
  const targetX = state.targetLane * state.laneWidth;
  playerGroup.position.x += (targetX - playerGroup.position.x) * 0.15;

  // Jump
  if (state.jumping) {
    state.jumpVel -= state.gravity;
    state.playerY += state.jumpVel;
    if (state.playerY <= 0) {
      state.playerY = 0;
      state.jumping = false;
      state.jumpVel = 0;
    }
  }
  playerGroup.position.y = state.playerY;

  // Running animation
  runAnim += dt * state.speed * 25;
  leftLeg.rotation.x = Math.sin(runAnim) * 0.6;
  rightLeg.rotation.x = Math.sin(runAnim + Math.PI) * 0.6;
  body.rotation.x = Math.sin(runAnim * 2) * 0.03;
  cloak.rotation.x = 0.1 + Math.sin(runAnim) * 0.05;

  // Attack timer
  if (state.attacking) {
    state.attackTimer -= dt;
    daggerGroup.rotation.z = Math.sin(state.attackTimer * 30) * 1.5;
    if (state.attackTimer <= 0) {
      state.attacking = false;
      daggerGroup.visible = false;
      daggerGroup.rotation.z = 0;
    }
  }

  // Cooldown
  if (state.hitCooldown > 0) {
    state.hitCooldown -= dt;
    body.material.emissive.setHex(0x222266);
    body.material.emissiveIntensity = 0.3 + Math.sin(Date.now() * 0.02) * 0.2;
  } else {
    body.material.emissive.setHex(0x000000);
    body.material.emissiveIntensity = 0;
  }

  // Score
  state.score += Math.floor(state.speed * 2);

  // Camera follow
  camera.position.x += (playerGroup.position.x * 0.3 - camera.position.x) * 0.08;
  camera.position.z = state.distance + 8;
  camera.lookAt(playerGroup.position.x * 0.5, 1.5, state.distance - 10);

  // Move ground/path with player
  ground.position.z = state.distance - 150;
  path.position.z = state.distance - 150;

  // Point light follows
  pointLight.position.set(playerGroup.position.x, 3, state.distance - 5);
  dirLight.position.set(playerGroup.position.x + 5, 15, state.distance + 10);
  dirLight.target.position.set(playerGroup.position.x, 0, state.distance);

  // Beast
  const beastSpeed = state.speed * (0.85 + state.cyclePhase * 0.2);
  if (Math.abs(state.distance) > 200) {
    state.beastDistance -= (state.speed - beastSpeed) * 0.3;
    state.beastDistance = Math.max(8, state.beastDistance);
    state.beastClosing = state.beastDistance < 25;
  }
  beastGroup.position.z = state.distance + state.beastDistance;
  beastGroup.position.x += (playerGroup.position.x - beastGroup.position.x) * 0.02;
  beastBody.rotation.y = Math.sin(Date.now() * 0.003) * 0.2;

  const beastWarn = document.getElementById('beast-warning');
  if (state.beastClosing) {
    beastWarn.classList.add('active');
    beastLight.intensity = 1.0 + Math.sin(Date.now() * 0.01) * 0.5;
  } else {
    beastWarn.classList.remove('active');
  }

  if (state.beastDistance <= 8) {
    gameOver();
    return;
  }

  // Collectible rotation
  for (const col of collectibles) {
    col.rotation.y += dt * (col.userData.rotSpeed || 2);
    col.position.y = 1.0 + Math.sin(Date.now() * 0.003 + col.position.z) * 0.2;
  }

  // Fairy hover
  for (const fairy of fairies) {
    if (fairy.userData.alive) {
      fairy.position.y = 1.5 + Math.sin(Date.now() * 0.004 + fairy.userData.bobPhase) * 0.4;
      fairy.rotation.y += dt * 2;
    }
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.userData.life -= dt * 2;
    p.position.add(p.userData.vel);
    p.userData.vel.y -= 0.005;
    p.material.opacity = Math.max(0, p.userData.life);
    if (p.userData.life <= 0) {
      scene.remove(p);
      particles.splice(i, 1);
    }
  }

  // Cycle
  updateCycle();

  // Spawn & cleanup
  spawnObjects();
  cleanupBehind();

  // Collisions
  checkCollisions();

  // HUD
  document.getElementById('score-val').textContent = state.score.toLocaleString();
  document.getElementById('dist-val').textContent = Math.floor(Math.abs(state.distance)) + 'm';
  document.getElementById('ash-val').textContent = state.ashShavings;
  document.getElementById('iron-val').textContent = state.ironCharms;
}

// ── RENDER LOOP ─────────────────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}
animate();

// ── START / RESTART ─────────────────────────────────────────────────────────
function startGame() {
  state.running = true;
  state.speed = state.baseSpeed;
  state.distance = 0;
  state.score = 0;
  state.ashShavings = 0;
  state.ironCharms = 0;
  state.lane = 0;
  state.targetLane = 0;
  state.jumping = false;
  state.jumpVel = 0;
  state.playerY = 0;
  state.beastDistance = 80;
  state.beastClosing = false;
  state.attacking = false;
  state.hitCooldown = 0;
  state.cyclePhase = 0;

  playerGroup.position.set(0, 0, 0);
  beastGroup.position.set(0, 0, 80);
  nextObstacleZ = -30;
  nextCollectibleZ = -20;
  nextFairyZ = -50;

  // Clear old objects
  for (const arr of [obstacles, collectibles, fairies, particles]) {
    while (arr.length) scene.remove(arr.pop());
  }

  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  clock.getDelta(); // reset clock
}

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);

// ── RESIZE ──────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
