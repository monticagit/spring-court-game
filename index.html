<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a1a0a">
<link rel="manifest" href="manifest.json">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet">
<title>Spring Court Runner</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#000;font-family:'Segoe UI',sans-serif;user-select:none}
canvas{display:block;position:relative;z-index:0}

#ui-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}

#hud{position:absolute;top:20px;left:20px;right:20px;display:flex;justify-content:space-between;align-items:flex-start}
#hud-left,#hud-right{display:flex;flex-direction:column;gap:8px}
.hud-item{background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.1);border-top:1px solid rgba(200,168,74,0.2);border-radius:10px;padding:10px 18px;color:#fff;font-size:14px;backdrop-filter:blur(6px);position:relative}
.hud-item::before{content:'╭';position:absolute;top:2px;left:6px;font-size:10px;color:rgba(200,168,74,0.3);line-height:1}
.hud-item::after{content:'╮';position:absolute;top:2px;right:6px;font-size:10px;color:rgba(200,168,74,0.3);line-height:1}
.hud-item .label{font-family:'Cinzel',Georgia,serif;font-size:10px;text-transform:uppercase;letter-spacing:1.5px;color:#9a8a6a}
.hud-item .value{font-size:22px;font-weight:700;color:#e8e0d0;transition:transform .2s ease-out,color .2s ease-out}
.hud-item .value.pop{transform:scale(1.2);color:#c8a84a}

#beast-warning{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff3333;font-size:28px;font-weight:700;text-transform:uppercase;letter-spacing:4px;opacity:0;text-shadow:0 0 30px #ff0000}
#beast-warning.active{animation:pulse .8s ease-in-out infinite}
@keyframes pulse{0%,100%{opacity:.3;transform:translate(-50%,-50%) scale(1)}50%{opacity:1;transform:translate(-50%,-50%) scale(1.1)}}

#cycle-indicator{position:absolute;top:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.1);border-top:2px solid rgba(200,168,74,0.3);border-radius:20px;padding:8px 28px;color:#fff;font-family:'Cinzel',Georgia,serif;font-size:12px;letter-spacing:3px;text-transform:uppercase;backdrop-filter:blur(6px);transition:all 1s}

#start-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(180deg,#0a1a0a 0%,#0a0f1a 50%,#080820 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;color:#fff;pointer-events:auto}
.title-decoration{display:flex;align-items:center;gap:12px;color:#c8a84a;margin-bottom:12px;position:relative}
.title-decoration::before{content:'✦';font-size:10px;opacity:0.5}
.title-decoration::after{content:'✦';font-size:10px;opacity:0.5}
#start-screen h1{font-family:'Cinzel',Georgia,serif;font-size:56px;font-weight:600;letter-spacing:12px;text-transform:uppercase;margin-bottom:4px;background:linear-gradient(90deg,#c8a84a,#e8d88a,#a8b0c8);-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-shadow:none}
#start-screen .subtitle{font-family:'Cinzel',Georgia,serif;font-size:18px;color:#8a7a5a;letter-spacing:8px;margin-bottom:50px;font-weight:400}
#start-screen .controls{font-size:13px;color:#555;line-height:2.2;text-align:center;margin-bottom:40px}
#start-screen .controls span{color:#c8a84a;font-weight:600}
#start-btn{pointer-events:all;cursor:pointer;background:none;border:1px solid rgba(200,168,74,0.3);color:#d4b45a;font-family:'Cinzel',Georgia,serif;font-size:16px;letter-spacing:6px;text-transform:uppercase;padding:16px 60px;border-radius:30px;transition:all .3s;position:relative}
#start-btn::before{content:'❧';position:absolute;left:16px;top:50%;transform:translateY(-50%);opacity:0.4;font-size:14px}
#start-btn::after{content:'❧';position:absolute;right:16px;top:50%;transform:translateY(-50%) scaleX(-1);opacity:0.4;font-size:14px}
#start-btn:hover{background:rgba(200,168,74,0.08);border-color:rgba(200,168,74,0.7);box-shadow:0 0 40px rgba(200,168,74,0.15)}

.story-page{display:none;flex-direction:column;align-items:center;justify-content:center;text-align:center;max-width:600px;padding:0 30px;animation:fadeInPage .6s ease}
.story-page.active{display:flex}
@keyframes fadeInPage{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
.story-page p{font-size:18px;line-height:1.9;color:#d0c8b8;font-weight:300;letter-spacing:0.5px;margin-bottom:30px}
.story-page p span{color:#c8a84a;font-weight:600;background:rgba(200,168,74,0.08);padding:2px 6px;border-radius:4px}
.story-page .page-num{font-family:'Cinzel',Georgia,serif;font-size:11px;color:#6a5a3a;letter-spacing:4px;text-transform:uppercase;margin-bottom:20px}
.story-page .page-num::before{content:'── '}
.story-page .page-num::after{content:' ──'}
.story-next{pointer-events:all;cursor:pointer;background:none;border:1px solid rgba(200,168,74,0.25);color:#c8a84a;font-family:'Cinzel',Georgia,serif;font-size:13px;letter-spacing:4px;text-transform:uppercase;padding:10px 36px;border-radius:20px;transition:all .3s;margin-top:10px}
.story-next:hover{background:rgba(200,168,74,0.06);border-color:rgba(200,168,74,0.5)}
.story-hint{font-size:11px;color:#3a3a3a;margin-top:16px;letter-spacing:1px}

#game-over{position:fixed;top:0;left:0;width:100%;height:100%;background:radial-gradient(1px 1px at 20% 15%,#fff 0.5px,transparent 1px),radial-gradient(1px 1px at 60% 25%,#aaf 0.5px,transparent 1px),radial-gradient(1px 1px at 80% 10%,#fff 0.5px,transparent 1px),radial-gradient(1px 1px at 35% 35%,#88f 0.5px,transparent 1px),radial-gradient(1px 1px at 10% 30%,#fff 0.5px,transparent 1px),radial-gradient(1px 1px at 50% 8%,#ccf 0.5px,transparent 1px),radial-gradient(1px 1px at 90% 20%,#fff 0.5px,transparent 1px),radial-gradient(1px 1px at 70% 40%,#aaf 0.5px,transparent 1px),linear-gradient(180deg,#0a0a2a 0%,#0a0820 60%,#1a0a1a 100%);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:100;color:#fff;overflow:hidden}
#game-over h2{font-family:'Cinzel',Georgia,serif;font-size:42px;font-weight:400;letter-spacing:8px;margin-bottom:30px;color:#cc4444;text-shadow:0 0 40px rgba(255,50,50,0.3)}
#game-over .final-score{font-family:'Cinzel',Georgia,serif;font-size:64px;font-weight:700;background:linear-gradient(90deg,#cc4444,#d4a848);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
#game-over .final-distance{font-family:'Cinzel',Georgia,serif;font-size:16px;color:#6a6a80;margin-bottom:40px}
#restart-btn{pointer-events:all;cursor:pointer;background:none;border:1px solid rgba(255,100,100,0.3);color:#faa;font-family:'Cinzel',Georgia,serif;font-size:16px;letter-spacing:4px;text-transform:uppercase;padding:14px 50px;border-radius:30px;transition:all .3s;position:relative;z-index:1}
#restart-btn:hover{background:rgba(255,100,100,0.08);border-color:rgba(255,100,100,0.7)}
.beast-eyes{position:absolute;top:18%;left:50%;transform:translateX(-50%);display:flex;gap:28px}
.beast-eyes span{width:8px;height:8px;border-radius:50%;background:#ff2200;box-shadow:0 0 15px #ff2200,0 0 40px rgba(255,34,0,0.4);animation:eyePulse 2s ease-in-out infinite}
@keyframes eyePulse{0%,100%{opacity:0.6;transform:scale(1)}50%{opacity:1;transform:scale(1.3)}}
.mountain-silhouette{position:absolute;bottom:0;left:0;right:0;height:80px;background:linear-gradient(180deg,transparent,rgba(20,20,40,0.8));clip-path:polygon(0 100%,5% 60%,15% 75%,25% 40%,35% 65%,45% 30%,55% 55%,65% 35%,75% 60%,85% 45%,95% 70%,100% 100%)}

#slash-canvas{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:6}

#speed-boost{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.5);border:1px solid rgba(255,200,50,0.2);border-radius:20px;padding:4px 20px;color:#da4;font-size:11px;letter-spacing:2px;opacity:0;transition:opacity .3s;backdrop-filter:blur(4px)}
#invincible{position:absolute;bottom:60px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.5);border:1px solid rgba(100,100,255,0.3);border-radius:20px;padding:4px 20px;color:#88f;font-size:11px;letter-spacing:2px;opacity:0;transition:opacity .3s;backdrop-filter:blur(4px)}

/* ── TOUCH CONTROLS ─────────────────────────────────────────────────── */
#touch-controls{position:fixed;bottom:0;left:0;right:0;z-index:8;pointer-events:none;padding-bottom:max(24px, env(safe-area-inset-bottom));display:none}
#touch-controls.visible{display:block}
#swipe-hint{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.4);border:1px solid rgba(200,168,74,0.2);border-radius:16px;padding:6px 20px;color:rgba(200,200,180,0.5);font-family:'Cinzel',Georgia,serif;font-size:11px;letter-spacing:2px;backdrop-filter:blur(4px);white-space:nowrap;opacity:1;transition:opacity 2s}
#swipe-hint.fade{opacity:0}

/* Rotate notice overlay */
#rotate-notice{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.92);z-index:200;display:none;flex-direction:column;align-items:center;justify-content:center;color:#afa;font-size:18px;letter-spacing:2px;gap:20px}
#rotate-notice svg{width:60px;height:60px;stroke:#afa;fill:none;stroke-width:1.5;animation:rotateHint 2s ease-in-out infinite}
@keyframes rotateHint{0%,100%{transform:rotate(0deg)}50%{transform:rotate(-90deg)}}

/* Responsive — small phones */
@media(max-width:480px){
  .hud-item{padding:5px 10px;font-size:12px}
  .hud-item .value{font-size:17px}
  #start-screen h1{font-size:28px;letter-spacing:6px}
  #start-screen .subtitle{font-size:12px;letter-spacing:4px}
  .title-decoration svg{width:28px;height:28px}
  .story-page p{font-size:15px}
  .story-page .page-num{font-size:10px}
  #game-over h2{font-size:28px;letter-spacing:4px}
  #game-over .final-score{font-size:48px}
  #game-over .final-distance{font-size:14px}
  #swipe-hint{font-size:10px;padding:5px 14px}
}

/* Landscape on mobile — show rotate notice */
@media(orientation:landscape) and (max-height:500px) and (pointer:coarse){
  #rotate-notice{display:flex}
}
</style>
</head>
<body>

<div id="start-screen">
  <div class="title-decoration">
    <svg class="crescent" viewBox="0 0 60 60" width="40" height="40">
      <path d="M30 5a25 25 0 1 0 0 50 20 20 0 0 1 0-50z" fill="currentColor"/>
    </svg>
  </div>
  <h1>Spring Court</h1>
  <div class="subtitle">R U N N E R</div>

  <div class="story-page active" data-page="1">
    <div class="page-num">I</div>
    <p>You are a mortal, lost in the Spring Court of Prythian. The ancient forest stretches endlessly &mdash; beautiful and deadly.</p>
    <button class="story-next">Continue</button>
    <div class="story-hint">Press Space or Enter</div>
  </div>

  <div class="story-page" data-page="2">
    <div class="page-num">II</div>
    <p>The Wild Hunt has found your scent. A shadow beast, born of old magic, pursues all who trespass. You must run.</p>
    <button class="story-next">Continue</button>
    <div class="story-hint">Press Space or Enter</div>
  </div>

  <div class="story-page" data-page="3">
    <div class="page-num">III</div>
    <p>Weave between the forest lanes with <span>A / D</span> or <span>Arrow Keys</span>. Leap over fallen logs and brambles, or onto ancient stones with <span>W / Space</span>.</p>
    <button class="story-next">Continue</button>
    <div class="story-hint">Press Space or Enter</div>
  </div>

  <div class="story-page" data-page="4">
    <div class="page-num">IV</div>
    <p>Gather ash shavings to quicken your pace. Collect iron charms to ward off fae magic. Strike down lesser fae with your ash dagger &mdash; <span>F</span>.</p>
    <button class="story-next">Continue</button>
    <div class="story-hint">Press Space or Enter</div>
  </div>

  <div class="story-page" data-page="5">
    <div class="page-num">V</div>
    <p>The world shifts between Spring Court and Night Court. The beast grows faster in darkness. How far can you run?</p>
    <button id="start-btn">Enter the Forest</button>
  </div>
</div>

<script>
(function() {
  var storyPage = 1;
  var pages = document.querySelectorAll('.story-page');
  var total = pages.length;
  function advance() {
    if (storyPage >= total) return;
    pages[storyPage - 1].classList.remove('active');
    storyPage++;
    pages[storyPage - 1].classList.add('active');
  }
  document.getElementById('start-screen').addEventListener('click', function(e) {
    if (e.target.classList.contains('story-next')) advance();
  });
  document.addEventListener('keydown', function(e) {
    var screen = document.getElementById('start-screen');
    if (screen.style.display === 'none') return;
    if (document.getElementById('game-over').style.display === 'flex') return;
    if (e.code === 'Space' || e.code === 'Enter') {
      e.preventDefault();
      if (storyPage < total) advance();
      else document.getElementById('start-btn').click();
    }
  });
})();
</script>

<div id="game-over">
  <div class="beast-eyes">
    <span></span><span></span>
  </div>
  <h2>Caught by the Hunt</h2>
  <div class="final-score" id="final-score">0</div>
  <div class="final-distance" id="final-distance">0m</div>
  <button id="restart-btn">Run Again</button>
  <div class="mountain-silhouette"></div>
</div>

<div id="ui-overlay">
  <div id="hud">
    <div id="hud-left">
      <div class="hud-item"><div class="label">Score</div><div class="value" id="score-val">0</div></div>
      <div class="hud-item"><div class="label">Distance</div><div class="value" id="dist-val">0m</div></div>
    </div>
    <div id="hud-right">
      <div class="hud-item"><div class="label">Ash Shavings</div><div class="value" id="ash-val">0</div></div>
      <div class="hud-item"><div class="label">Iron Charms</div><div class="value" id="iron-val">0</div></div>
    </div>
  </div>
  <div id="cycle-indicator">Spring Court</div>
  <div id="beast-warning">The Hunt approaches...</div>
  <div id="speed-boost">SPEED +</div>
  <div id="invincible">IRON SHIELD</div>
</div>

<canvas id="slash-canvas"></canvas>

<div id="touch-controls">
  <div id="swipe-hint">Swipe ← → ↑ &nbsp;|&nbsp; Tap to attack</div>
</div>

<div id="rotate-notice">
  <svg viewBox="0 0 64 64"><rect x="16" y="8" width="32" height="48" rx="4"/><circle cx="32" cy="50" r="2"/></svg>
  <span>Rotate to portrait</span>
</div>

<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"}}</script>

<script type="module">
import * as THREE from 'three';

// ── MOBILE DETECTION & STORY TEXT SWAP ───────────────────────────────────
const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

if (isMobile) {
  const page3 = document.querySelector('.story-page[data-page="3"] p');
  if (page3) page3.innerHTML = 'Weave between the forest lanes by <span>swiping left / right</span>. Leap over fallen logs and brambles, or onto ancient stones by <span>swiping up</span>.';
  const page4 = document.querySelector('.story-page[data-page="4"] p');
  if (page4) page4.innerHTML = 'Gather ash shavings to quicken your pace. Collect iron charms to ward off fae magic. Strike down lesser fae with your ash dagger &mdash; <span>tap to attack</span>.';
  document.querySelectorAll('.story-hint').forEach(h => { h.textContent = 'Tap to continue'; });
}

// ═══════════════════════════════════════════════════════════════════════════
// AUDIO ENGINE — Procedural music via Web Audio API
// ═══════════════════════════════════════════════════════════════════════════
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.started = false;
    this.dayGain = null;
    this.nightGain = null;
    this.masterGain = null;
  }

  init() {
    if (this.started) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.masterGain = this.ctx.createGain();
    this.masterGain.gain.value = 0.3;
    this.masterGain.connect(this.ctx.destination);

    // Day channel
    this.dayGain = this.ctx.createGain();
    this.dayGain.gain.value = 1;
    this.dayGain.connect(this.masterGain);

    // Night channel
    this.nightGain = this.ctx.createGain();
    this.nightGain.gain.value = 0;
    this.nightGain.connect(this.masterGain);

    this._startDayMusic();
    this._startNightMusic();
    this.started = true;
  }

  _startDayMusic() {
    // Harp-like arpeggios with chimes
    const notes = [261.6, 329.6, 392, 523.3, 392, 329.6]; // C E G C' G E
    let idx = 0;
    const play = () => {
      if (!this.ctx) return;
      const osc = this.ctx.createOscillator();
      const env = this.ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = notes[idx % notes.length];
      env.gain.setValueAtTime(0.15, this.ctx.currentTime);
      env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
      osc.connect(env);
      env.connect(this.dayGain);
      osc.start(this.ctx.currentTime);
      osc.stop(this.ctx.currentTime + 0.8);

      // Chime overtone
      const chime = this.ctx.createOscillator();
      const chimeEnv = this.ctx.createGain();
      chime.type = 'sine';
      chime.frequency.value = notes[idx % notes.length] * 3;
      chimeEnv.gain.setValueAtTime(0.03, this.ctx.currentTime);
      chimeEnv.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
      chime.connect(chimeEnv);
      chimeEnv.connect(this.dayGain);
      chime.start(this.ctx.currentTime);
      chime.stop(this.ctx.currentTime + 0.4);

      idx++;
      this._dayTimer = setTimeout(play, 500 - Math.min(100, state.speed * 50));
    };
    play();
  }

  _startNightMusic() {
    // Deep cello drone + ethereal pad
    const drone = () => {
      if (!this.ctx) return;
      const osc = this.ctx.createOscillator();
      const env = this.ctx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.value = 65.4; // C2 cello
      const filter = this.ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 400;
      filter.Q.value = 2;
      env.gain.setValueAtTime(0.08, this.ctx.currentTime);
      env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
      osc.connect(filter);
      filter.connect(env);
      env.connect(this.nightGain);
      osc.start(this.ctx.currentTime);
      osc.stop(this.ctx.currentTime + 3);

      // Ethereal pad
      const pad = this.ctx.createOscillator();
      const padEnv = this.ctx.createGain();
      pad.type = 'sine';
      const padNotes = [196, 246.9, 293.7, 349.2];
      pad.frequency.value = padNotes[Math.floor(Math.random() * padNotes.length)];
      padEnv.gain.setValueAtTime(0.04, this.ctx.currentTime);
      padEnv.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2.5);
      pad.connect(padEnv);
      padEnv.connect(this.nightGain);
      pad.start(this.ctx.currentTime);
      pad.stop(this.ctx.currentTime + 2.5);

      this._nightTimer = setTimeout(drone, 2500);
    };
    drone();
  }

  setCycle(t) {
    if (!this.started) return;
    // t: 0 = day, 1 = night
    this.dayGain.gain.linearRampToValueAtTime(1 - t, this.ctx.currentTime + 0.5);
    this.nightGain.gain.linearRampToValueAtTime(t, this.ctx.currentTime + 0.5);
  }

  playCollect(type) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = type === 'ash' ? 880 : 1200;
    osc.frequency.exponentialRampToValueAtTime(type === 'ash' ? 1320 : 1800, this.ctx.currentTime + 0.15);
    env.gain.setValueAtTime(0.2, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
    osc.connect(env);
    env.connect(this.masterGain);
    osc.start(); osc.stop(this.ctx.currentTime + 0.25);
  }

  playSlash() {
    if (!this.ctx) return;
    // White noise burst
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.15, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const env = this.ctx.createGain();
    env.gain.setValueAtTime(0.15, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 2000;
    src.connect(filter);
    filter.connect(env);
    env.connect(this.masterGain);
    src.start();
  }

  playKill() {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 600;
    osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.3);
    env.gain.setValueAtTime(0.15, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    osc.connect(env);
    env.connect(this.masterGain);
    osc.start(); osc.stop(this.ctx.currentTime + 0.3);
  }

  setHuntIntensity(v) {
    if (!this.started) return;
    this.masterGain.gain.linearRampToValueAtTime(0.3 + v * 0.15, this.ctx.currentTime + 0.3);
  }

  stop() {
    clearTimeout(this._dayTimer);
    clearTimeout(this._nightTimer);
    if (this.ctx) { this.ctx.close(); this.ctx = null; }
    this.started = false;
  }
}

const audio = new AudioEngine();

// ═══════════════════════════════════════════════════════════════════════════
// SLASH CANVAS — 2D overlay for dagger trail
// ═══════════════════════════════════════════════════════════════════════════
const slashCanvas = document.getElementById('slash-canvas');
const slashCtx = slashCanvas.getContext('2d');
let slashTrails = [];

function resizeSlash() {
  slashCanvas.width = window.innerWidth;
  slashCanvas.height = window.innerHeight;
}
resizeSlash();

function triggerSlash() {
  const cx = window.innerWidth * 0.5;
  const cy = window.innerHeight * 0.45;
  const trail = { points: [], life: 1, color: `hsl(35,80%,60%)` };
  for (let i = 0; i < 12; i++) {
    const a = -0.8 + (i / 11) * 1.6;
    const r = 80 + Math.sin(i * 0.5) * 30;
    trail.points.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r * 0.6 });
  }
  slashTrails.push(trail);
}

function updateSlashCanvas(dt) {
  slashCtx.clearRect(0, 0, slashCanvas.width, slashCanvas.height);
  for (let i = slashTrails.length - 1; i >= 0; i--) {
    const t = slashTrails[i];
    t.life -= dt * 3;
    if (t.life <= 0) { slashTrails.splice(i, 1); continue; }
    slashCtx.save();
    slashCtx.globalAlpha = t.life;
    slashCtx.strokeStyle = t.color;
    slashCtx.lineWidth = 3 * t.life;
    slashCtx.shadowColor = '#ffaa33';
    slashCtx.shadowBlur = 20 * t.life;
    slashCtx.beginPath();
    for (let j = 0; j < t.points.length; j++) {
      const p = t.points[j];
      if (j === 0) slashCtx.moveTo(p.x, p.y);
      else slashCtx.lineTo(p.x, p.y);
    }
    slashCtx.stroke();
    // Ember particles along trail
    for (let j = 0; j < t.points.length; j += 2) {
      const p = t.points[j];
      const sz = 2 * t.life * Math.random();
      slashCtx.fillStyle = `hsl(${25 + Math.random() * 20},90%,${50 + Math.random() * 30}%)`;
      slashCtx.fillRect(p.x + (Math.random() - 0.5) * 20, p.y + (Math.random() - 0.5) * 20, sz, sz);
    }
    slashCtx.restore();
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// GAME STATE
// ═══════════════════════════════════════════════════════════════════════════
const state = {
  running: false,
  speed: 0.35, baseSpeed: 0.35, maxSpeed: 0.9, speedBoost: 0,
  lane: 0, targetLane: 0, laneWidth: 2.5,
  jumping: false, jumpVel: 0, jumpForce: 0.28, gravity: 0.012, playerY: 0,
  distance: 0, score: 0, ashShavings: 0, ironCharms: 0,
  cyclePhase: 0,
  beastDistance: 80, beastClosing: false,
  attacking: false, attackTimer: 0,
  hitCooldown: 0,
  onPlatform: null,
};

// ── CACHED DOM REFS ──────────────────────────────────────────────────────
const dom = {
  scoreVal: document.getElementById('score-val'),
  distVal: document.getElementById('dist-val'),
  ashVal: document.getElementById('ash-val'),
  ironVal: document.getElementById('iron-val'),
  cycleIndicator: document.getElementById('cycle-indicator'),
  beastWarning: document.getElementById('beast-warning'),
  speedBoost: document.getElementById('speed-boost'),
  invincible: document.getElementById('invincible'),
  startScreen: document.getElementById('start-screen'),
  gameOver: document.getElementById('game-over'),
  finalScore: document.getElementById('final-score'),
  finalDistance: document.getElementById('final-distance'),
};

// ═══════════════════════════════════════════════════════════════════════════
// THREE.JS SETUP
// ═══════════════════════════════════════════════════════════════════════════
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x1a3a1a, 0.012);

const camera = new THREE.PerspectiveCamera(72, innerWidth / innerHeight, 0.1, 250);
camera.position.set(0, 4.5, 8);

const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: 'high-performance' });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(1);
renderer.shadowMap.enabled = false;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.8;
document.body.appendChild(renderer.domElement);

// ── LIGHTING ────────────────────────────────────────────────────────────
const ambientLight = new THREE.AmbientLight(0x6aaa6a, 1.2);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffeedd, 1.6);
dirLight.position.set(5, 15, 10);
dirLight.castShadow = false;
scene.add(dirLight);
scene.add(dirLight.target);

// Magical ambient (single scene PointLight)
const magicLight = new THREE.PointLight(0x44ff88, 0.8, 30);
scene.add(magicLight);

// ── PROCEDURAL TEXTURES ─────────────────────────────────────────────────
function createGrassTexture() {
  const c = document.createElement('canvas'); c.width = 256; c.height = 256;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#2a4a22'; ctx.fillRect(0, 0, 256, 256);
  for (let i = 0; i < 3000; i++) {
    const x = Math.random() * 256, y = Math.random() * 256;
    const g = Math.random() > 0.5 ? Math.floor(40 + Math.random() * 30) : Math.floor(20 + Math.random() * 20);
    ctx.fillStyle = `rgb(${Math.floor(30+Math.random()*20)},${g},${Math.floor(20+Math.random()*15)})`;
    ctx.fillRect(x, y, 1 + Math.random(), 1 + Math.random());
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(20, 50);
  return tex;
}
function createDirtTexture() {
  const c = document.createElement('canvas'); c.width = 256; c.height = 256;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#4a3a1a'; ctx.fillRect(0, 0, 256, 256);
  for (let i = 0; i < 2000; i++) {
    const x = Math.random() * 256, y = Math.random() * 256;
    const b = Math.random() > 0.5 ? Math.floor(50 + Math.random() * 30) : Math.floor(30 + Math.random() * 20);
    ctx.fillStyle = `rgb(${b},${Math.floor(b*0.7)},${Math.floor(b*0.3)})`;
    ctx.fillRect(x, y, 1 + Math.random(), 1 + Math.random());
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(4, 50);
  return tex;
}
const grassTex = createGrassTexture();
const dirtTex = createDirtTexture();

// ── GROUND ──────────────────────────────────────────────────────────────
const groundGeo = new THREE.PlaneGeometry(200, 500);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a4a22, roughness: 0.95, map: grassTex });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2; ground.position.z = -200;
scene.add(ground);

// Path
const pathGeo = new THREE.PlaneGeometry(8, 500);
const pathMat = new THREE.MeshStandardMaterial({ color: 0x4a3a1a, roughness: 0.85, map: dirtTex });
const pathMesh = new THREE.Mesh(pathGeo, pathMat);
pathMesh.rotation.x = -Math.PI / 2; pathMesh.position.y = 0.01; pathMesh.position.z = -200;
scene.add(pathMesh);

// Lane markers
for (let i = -1; i <= 1; i += 2) {
  const m = new THREE.Mesh(new THREE.PlaneGeometry(0.04, 500),
    new THREE.MeshBasicMaterial({ color: 0x444, transparent: true, opacity: 0.2 }));
  m.rotation.x = -Math.PI / 2; m.position.set(i * state.laneWidth / 2, 0.02, -200);
  scene.add(m);
}

// ── GRASS PATCHES (ground detail) ───────────────────────────────────────
const grassPatches = [];
function createGrassPatch(x, z) {
  const g = new THREE.Group();
  const blades = 3 + Math.floor(Math.random() * 3);
  const mat = new THREE.MeshStandardMaterial({ color: 0x2a6a1a, roughness: 0.9, side: THREE.DoubleSide });
  for (let i = 0; i < blades; i++) {
    const geo = new THREE.PlaneGeometry(0.05, 0.3 + Math.random() * 0.3);
    const blade = new THREE.Mesh(geo, mat);
    blade.position.set((Math.random() - 0.5) * 0.5, 0.15, (Math.random() - 0.5) * 0.5);
    blade.rotation.y = Math.random() * Math.PI;
    blade.rotation.x = (Math.random() - 0.5) * 0.3;
    blade.userData.baseRotX = blade.rotation.x;
    g.add(blade);
  }
  g.position.set(x, 0, z);
  return g;
}

// ── FLOWERS (spring court) ──────────────────────────────────────────────
const flowers = [];
function createFlower(x, z) {
  const g = new THREE.Group();
  const colors = [0xff88aa, 0x88ccff, 0xffaadd, 0xaaddff, 0xffccee];
  const color = colors[Math.floor(Math.random() * colors.length)];
  // Petals
  for (let i = 0; i < 5; i++) {
    const pGeo = new THREE.SphereGeometry(0.06, 4, 4);
    const pMat = new THREE.MeshStandardMaterial({
      color, emissive: color, emissiveIntensity: 0.4, roughness: 0.5
    });
    const petal = new THREE.Mesh(pGeo, pMat);
    const a = (i / 5) * Math.PI * 2;
    petal.position.set(Math.cos(a) * 0.08, 0.25, Math.sin(a) * 0.08);
    petal.scale.set(1, 0.5, 1);
    g.add(petal);
  }
  // Center
  const cGeo = new THREE.SphereGeometry(0.04, 4, 4);
  const cMat = new THREE.MeshStandardMaterial({ color: 0xffee44, emissive: 0xffee44, emissiveIntensity: 0.6 });
  const center = new THREE.Mesh(cGeo, cMat);
  center.position.y = 0.25;
  g.add(center);
  // Stem
  const sGeo = new THREE.CylinderGeometry(0.01, 0.015, 0.25, 4);
  const sMat = new THREE.MeshStandardMaterial({ color: 0x2a5a1a });
  const stem = new THREE.Mesh(sGeo, sMat);
  stem.position.y = 0.125;
  g.add(stem);
  g.position.set(x, 0, z);
  g.userData = { baseY: 0.25, phase: Math.random() * Math.PI * 2 };
  return g;
}

// ── MUSHROOMS (night court, bioluminescent) ─────────────────────────────
const mushrooms = [];
function createMushroom(x, z) {
  const g = new THREE.Group();
  const colors = [0x22ffaa, 0x44ddff, 0xaa88ff, 0x88ffcc];
  const color = colors[Math.floor(Math.random() * colors.length)];
  const capGeo = new THREE.SphereGeometry(0.15, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
  const capMat = new THREE.MeshStandardMaterial({
    color, emissive: color, emissiveIntensity: 0.6, roughness: 0.4,
    transparent: true, opacity: 0.9
  });
  const cap = new THREE.Mesh(capGeo, capMat);
  cap.position.y = 0.2;
  g.add(cap);
  const stemGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.2, 6);
  const stemMat = new THREE.MeshStandardMaterial({ color: 0xddddcc, roughness: 0.8 });
  g.add(new THREE.Mesh(stemGeo, stemMat));
  g.position.set(x, 0, z);
  g.userData = { glowBase: 0.3, phase: Math.random() * Math.PI * 2, color };
  return g;
}

// ── WILL-O-WISPS (night court floating lights) ──────────────────────────
const wisps = [];
const wispHaloMats = [
  new THREE.MeshBasicMaterial({ color: 0x44ffaa, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false }),
  new THREE.MeshBasicMaterial({ color: 0x88aaff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false }),
  new THREE.MeshBasicMaterial({ color: 0xcc88ff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false }),
  new THREE.MeshBasicMaterial({ color: 0x44ddcc, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false })
];
const wispHaloGeo = new THREE.SphereGeometry(0.25, 6, 6);
function createWisp(x, z) {
  const colors = [0x44ffaa, 0x88aaff, 0xcc88ff, 0x44ddcc];
  const ci = Math.floor(Math.random() * colors.length);
  const color = colors[ci];
  const g = new THREE.Group();
  const core = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6),
    new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.7 }));
  g.add(core);
  const halo = new THREE.Mesh(wispHaloGeo, wispHaloMats[ci]);
  g.add(halo);
  g.position.set(x, 1.5 + Math.random() * 2, z);
  g.userData = { baseY: g.position.y, phase: Math.random() * Math.PI * 2, baseX: x, speed: 0.5 + Math.random() * 1.5 };
  return g;
}

// ── AURORA (night court sky effect) ─────────────────────────────────────
const auroraGroup = new THREE.Group();
const auroraMaterials = [];
for (let i = 0; i < 5; i++) {
  const colors = [0x22ff88, 0x8844ff, 0xccccff, 0x44ffaa, 0xaa66ff];
  const geo = new THREE.PlaneGeometry(60, 3, 30, 1);
  const mat = new THREE.MeshBasicMaterial({
    color: colors[i], transparent: true, opacity: 0, side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set((i - 2) * 8, 30 + i * 2, -40);
  mesh.rotation.x = -0.3;
  mesh.userData = { phase: i * 1.2 };
  auroraGroup.add(mesh);
  auroraMaterials.push(mat);
  // Animate vertices for wave
  const posAttr = geo.attributes.position;
  mesh.userData.origPositions = new Float32Array(posAttr.array);
}
scene.add(auroraGroup);

// ── SUN RAYS (day court, volumetric-like beams) ─────────────────────────
const sunRays = [];
for (let i = 0; i < 8; i++) {
  const geo = new THREE.PlaneGeometry(0.3, 15);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffeedd, transparent: true, opacity: 0.04, side: THREE.DoubleSide
  });
  const ray = new THREE.Mesh(geo, mat);
  ray.position.set(-8 + i * 2.5 + Math.random() * 2, 8, -20 + Math.random() * 10);
  ray.rotation.z = (Math.random() - 0.5) * 0.3;
  ray.rotation.y = Math.random() * 0.5;
  scene.add(ray);
  sunRays.push(ray);
}

// ── GROUND PARTICLES (dust motes) ───────────────────────────────────────
const dustGeo = new THREE.BufferGeometry();
const dustCount = 120;
const dustPositions = new Float32Array(dustCount * 3);
const dustSizes = new Float32Array(dustCount);
for (let i = 0; i < dustCount; i++) {
  dustPositions[i * 3] = (Math.random() - 0.5) * 30;
  dustPositions[i * 3 + 1] = Math.random() * 5;
  dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
  dustSizes[i] = 0.5 + Math.random() * 3;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
dustGeo.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));
const dustMat = new THREE.PointsMaterial({
  color: 0xffeedd, size: 0.06, transparent: true, opacity: 0.3,
  blending: THREE.AdditiveBlending, depthWrite: false
});
const dustParticles = new THREE.Points(dustGeo, dustMat);
scene.add(dustParticles);

// ── PLAYER ──────────────────────────────────────────────────────────────
const playerGroup = new THREE.Group();

const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcc8866, roughness: 0.6 });
const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 1.0, 8), bodyMat);
body.position.y = 1.0; playerGroup.add(body);

const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12),
  new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.5 }));
head.position.y = 1.75; playerGroup.add(head);

const hair = new THREE.Mesh(new THREE.ConeGeometry(0.28, 0.6, 8),
  new THREE.MeshStandardMaterial({ color: 0x553322, roughness: 0.8 }));
hair.position.set(0, 1.85, 0.1); hair.rotation.x = 0.3; playerGroup.add(hair);

const cloak = new THREE.Mesh(new THREE.ConeGeometry(0.55, 1.3, 12),
  new THREE.MeshStandardMaterial({ color: 0x2a3a2a, roughness: 0.85 }));
cloak.position.set(0, 0.8, 0.15); playerGroup.add(cloak);

// Arms
const armMat = new THREE.MeshStandardMaterial({ color: 0xcc8866, roughness: 0.6 });
const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.55, 6), armMat);
leftArm.position.set(-0.38, 1.15, 0); playerGroup.add(leftArm);
const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.55, 6), armMat);
rightArm.position.set(0.38, 1.15, 0); playerGroup.add(rightArm);

// Boots
const bootMat = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness: 0.9 });
const leftBoot = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.13, 0.15, 6), bootMat);
leftBoot.position.set(-0.15, 0.05, 0); playerGroup.add(leftBoot);
const rightBoot = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.13, 0.15, 6), bootMat);
rightBoot.position.set(0.15, 0.05, 0); playerGroup.add(rightBoot);

// Dagger
const daggerGroup = new THREE.Group();
const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.5, 0.05),
  new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.9, roughness: 0.1, emissive: 0x443300, emissiveIntensity: 0 }));
blade.position.y = 0.25; daggerGroup.add(blade);
const hilt = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.1),
  new THREE.MeshStandardMaterial({ color: 0x5a3a1a }));
daggerGroup.add(hilt);
daggerGroup.position.set(0.55, 1.3, -0.2);
daggerGroup.visible = false;
playerGroup.add(daggerGroup);

// Legs
const legMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8 });
const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8), legMat);
leftLeg.position.set(-0.15, 0.3, 0); playerGroup.add(leftLeg);
const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8), legMat);
rightLeg.position.set(0.15, 0.3, 0); playerGroup.add(rightLeg);

scene.add(playerGroup);

// Blob shadow under player
const shadowCanvas = document.createElement('canvas'); shadowCanvas.width = 32; shadowCanvas.height = 32;
const shadowCtx = shadowCanvas.getContext('2d');
const shadowGrad = shadowCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
shadowGrad.addColorStop(0, 'rgba(0,0,0,0.7)'); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
shadowCtx.fillStyle = shadowGrad; shadowCtx.fillRect(0, 0, 32, 32);
const shadowTex = new THREE.CanvasTexture(shadowCanvas);
const playerShadow = new THREE.Mesh(
  new THREE.PlaneGeometry(1.2, 1.2),
  new THREE.MeshBasicMaterial({ map: shadowTex, transparent: true, depthWrite: false })
);
playerShadow.rotation.x = -Math.PI / 2;
playerShadow.position.y = 0.02;
scene.add(playerShadow);

// Trail particles pool
const trailPool = [];
const trailGeo = new THREE.SphereGeometry(0.03, 3, 3);
const trailMat = new THREE.MeshBasicMaterial({ color: 0xddcc99, transparent: true, opacity: 0.5 });
for (let i = 0; i < 20; i++) {
  const tm = new THREE.Mesh(trailGeo, trailMat.clone());
  tm.visible = false;
  tm.userData = { life: 0 };
  scene.add(tm);
  trailPool.push(tm);
}
let trailIdx = 0, trailTimer = 0;

// ── BEAST ───────────────────────────────────────────────────────────────
const beastGroup = new THREE.Group();
const beastBody = new THREE.Mesh(
  new THREE.IcosahedronGeometry(1.2, 1),
  new THREE.MeshStandardMaterial({ color: 0x1a0505, roughness: 0.4, emissive: 0x330000, emissiveIntensity: 0.4 })
);
beastBody.scale.set(1, 0.7, 1.5); beastBody.position.y = 1.2; beastGroup.add(beastBody);
// Tendrils (shared material)
const beastTendrils = [];
const tendrilMat = new THREE.MeshStandardMaterial({ color: 0x1a0505, emissive: 0x220000, emissiveIntensity: 0.3 });
for (let i = 0; i < 8; i++) {
  const t = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.02, 1.5, 4), tendrilMat);
  t.position.set((Math.random() - 0.5) * 1.5, 0.5, 0.5 + Math.random());
  const bRotX = 0.5 + Math.random() * 0.5;
  const bRotZ = (Math.random() - 0.5) * 0.8;
  t.rotation.x = bRotX; t.rotation.z = bRotZ;
  t.userData = { baseRotX: bRotX, baseRotZ: bRotZ, phaseX: Math.random() * Math.PI * 2, phaseZ: Math.random() * Math.PI * 2 };
  beastGroup.add(t);
  beastTendrils.push(t);
}
// Eyes (slit shape)
const beastEyes = [];
for (let s of [-1, 1]) {
  const eye = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8),
    new THREE.MeshBasicMaterial({ color: 0xff2200 }));
  eye.position.set(s * 0.4, 1.5, -1.2);
  eye.scale.set(1.4, 0.7, 1.0);
  beastGroup.add(eye);
  beastEyes.push(eye);
}
// Smoke aura (sprite)
const smokeCanvas = document.createElement('canvas'); smokeCanvas.width = 64; smokeCanvas.height = 64;
const smokeCtx = smokeCanvas.getContext('2d');
const smokeGrad = smokeCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
smokeGrad.addColorStop(0, 'rgba(20,5,5,0.6)'); smokeGrad.addColorStop(1, 'rgba(20,5,5,0)');
smokeCtx.fillStyle = smokeGrad; smokeCtx.fillRect(0, 0, 64, 64);
const smokeTex = new THREE.CanvasTexture(smokeCanvas);
const beastSmoke = new THREE.Sprite(new THREE.SpriteMaterial({ map: smokeTex, transparent: true, opacity: 0.5, depthWrite: false }));
beastSmoke.scale.set(6, 4, 1); beastSmoke.position.set(0, 1.2, 1.5);
beastGroup.add(beastSmoke);

const beastLight = new THREE.PointLight(0xff2200, 0.5, 20);
beastLight.position.y = 2; beastGroup.add(beastLight);
beastGroup.position.set(0, 0, 80);
scene.add(beastGroup);

// ── OBJECT POOLS ────────────────────────────────────────────────────────
const trees = [], obstacles = [], collectibles = [], fairies = [], particles = [];
const envObjects = []; // flowers, mushrooms, wisps, grass

const treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x3a2510, roughness: 0.95 });
const treeCanopyMat = new THREE.MeshStandardMaterial({ color: 0x1a5a1a, roughness: 0.85 });

function createTree() {
  const g = new THREE.Group();
  const h = 4 + Math.random() * 5;
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.35, h, 6), treeTrunkMat);
  trunk.position.y = h / 2; g.add(trunk);
  // Branch stubs
  const branchCount = 1 + Math.floor(Math.random() * 2);
  for (let b = 0; b < branchCount; b++) {
    const bLen = 0.6 + Math.random() * 0.5;
    const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.07, bLen, 4), treeTrunkMat);
    branch.position.set(0, h * 0.4 + b * h * 0.2, 0);
    branch.rotation.z = (Math.random() > 0.5 ? 1 : -1) * (0.6 + Math.random() * 0.6);
    branch.rotation.y = Math.random() * Math.PI * 2;
    g.add(branch);
  }
  // Canopy layers (icosahedral for organic faceted look)
  for (let j = 0; j < 2 + Math.floor(Math.random() * 2); j++) {
    const r = 1.0 + Math.random() * 1.0;
    const canopy = new THREE.Mesh(new THREE.IcosahedronGeometry(r, 1), treeCanopyMat);
    canopy.position.set((Math.random() - 0.5) * 0.8, h + j * 0.8, (Math.random() - 0.5) * 0.8);
    canopy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
    g.add(canopy);
  }
  return g;
}

function createObstacle(type) {
  const g = new THREE.Group();
  if (type === 'bramble') {
    const mat = new THREE.MeshStandardMaterial({ color: 0x3a2a15, roughness: 0.9 });
    for (let i = 0; i < 6; i++) {
      const vine = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.07, 1.0 + Math.random() * 0.4, 5), mat);
      vine.position.set((Math.random() - 0.5) * 1.2, 0.5, (Math.random() - 0.5) * 0.6);
      vine.rotation.set((Math.random() - 0.5) * 0.5, 0, (Math.random() - 0.5) * 0.8);
      g.add(vine);
    }
    const thornMat = new THREE.MeshStandardMaterial({ color: 0x2a6a2a, emissive: 0x0a3a0a, emissiveIntensity: 0.3 });
    for (let i = 0; i < 10; i++) {
      const thorn = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.15, 4), thornMat);
      thorn.position.set((Math.random() - 0.5) * 1.5, Math.random() * 1.0, (Math.random() - 0.5) * 0.5);
      thorn.rotation.z = Math.random() * Math.PI;
      g.add(thorn);
    }
    g.userData = { type: 'bramble', hitbox: { w: 1.5, h: 1.2 } };
  } else if (type === 'rock') {
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x6a6a60, roughness: 0.85 });
    const rock = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.7, 0.5, 8), rockMat);
    rock.position.y = 0.25; g.add(rock);
    // Moss accents on top
    const mossMat = new THREE.MeshStandardMaterial({ color: 0x3a7a2a, roughness: 0.9 });
    for (let i = 0; i < 3; i++) {
      const moss = new THREE.Mesh(new THREE.SphereGeometry(0.08 + Math.random() * 0.06, 5, 5), mossMat);
      const a = Math.random() * Math.PI * 2;
      moss.position.set(Math.cos(a) * 0.3, 0.5, Math.sin(a) * 0.3);
      g.add(moss);
    }
    g.userData = { type: 'rock', hitbox: { w: 1.2, h: 0.5 }, jumpable: true };
  } else {
    const log = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 3.5, 8),
      new THREE.MeshStandardMaterial({ color: 0x3a2510, roughness: 0.95 }));
    log.rotation.z = Math.PI / 2; log.position.y = 0.35; g.add(log);
    for (let i = 0; i < 4; i++) {
      const moss = new THREE.Mesh(new THREE.SphereGeometry(0.12 + Math.random() * 0.1, 5, 5),
        new THREE.MeshStandardMaterial({ color: 0x2a6a2a, roughness: 0.9 }));
      moss.position.set((Math.random() - 0.5) * 2.5, 0.5, (Math.random() - 0.5) * 0.3);
      g.add(moss);
    }
    g.userData = { type: 'log', hitbox: { w: 2.5, h: 0.8 } };
  }
  return g;
}

function createCollectible(type) {
  const g = new THREE.Group();
  if (type === 'ash') {
    const mesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.22, 0),
      new THREE.MeshStandardMaterial({ color: 0xddaa44, emissive: 0xcc8822, emissiveIntensity: 0.6, metalness: 0.4, roughness: 0.3 }));
    g.add(mesh);
    g.userData = { type: 'ash', rotSpeed: 2 + Math.random() };
  } else {
    const mesh = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.06, 8, 16),
      new THREE.MeshStandardMaterial({ color: 0x8888cc, emissive: 0x4444aa, emissiveIntensity: 0.5, metalness: 0.9, roughness: 0.1 }));
    g.add(mesh);
    g.userData = { type: 'iron', rotSpeed: 3 + Math.random() };
  }
  g.position.y = 1.0;
  return g;
}

function createFairy() {
  const g = new THREE.Group();
  const faeColor = state.cyclePhase > 0.5 ? 0x8844ff : 0x6633aa;
  const bodyMesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8),
    new THREE.MeshStandardMaterial({ color: faeColor, emissive: faeColor, emissiveIntensity: 0.5, roughness: 0.3 }));
  g.add(bodyMesh);
  for (let s of [-1, 1]) {
    const wing = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.3),
      new THREE.MeshBasicMaterial({ color: 0xbb88ff, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
    wing.position.set(s * 0.35, 0.1, 0);
    wing.rotation.y = s * 0.5;
    g.add(wing);
  }
  // Pulsing eyes
  for (let s of [-1, 1]) {
    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.07, 6, 6),
      new THREE.MeshBasicMaterial({ color: 0xffff00 }));
    eye.position.set(s * 0.12, 0.08, -0.25);
    g.add(eye);
  }
  g.position.y = 1.5;
  g.userData = { type: 'fairy', alive: true, hitbox: { w: 0.8, h: 1.0 },
    bobPhase: Math.random() * Math.PI * 2 };
  return g;
}

function spawnParticle(pos, color, count = 1) {
  for (let i = 0; i < count; i++) {
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.05, 4, 4),
      new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 }));
    mesh.position.copy(pos);
    mesh.userData = {
      vel: new THREE.Vector3((Math.random() - 0.5) * 0.2, 0.05 + Math.random() * 0.2, (Math.random() - 0.5) * 0.15),
      life: 1
    };
    scene.add(mesh);
    particles.push(mesh);
  }
}

// ── SPAWN MANAGEMENT ────────────────────────────────────────────────────
let nextObsZ = -30, nextColZ = -20, nextFairyZ = -50, nextEnvZ = -5;

function spawnObjects() {
  const farZ = playerGroup.position.z - 100;

  while (nextObsZ > farZ) {
    const r = Math.random();
    const obs = createObstacle(r < 0.2 ? 'rock' : r < 0.6 ? 'bramble' : 'log');
    obs.position.set(Math.floor(Math.random() * 3 - 1) * state.laneWidth, 0, nextObsZ);
    scene.add(obs); obstacles.push(obs);
    nextObsZ -= 12 + Math.random() * 15;
  }
  while (nextColZ > farZ) {
    const col = createCollectible(Math.random() > 0.3 ? 'ash' : 'iron');
    col.position.set(Math.floor(Math.random() * 3 - 1) * state.laneWidth, 1.0, nextColZ);
    scene.add(col); collectibles.push(col);
    nextColZ -= 6 + Math.random() * 10;
  }
  while (nextFairyZ > farZ) {
    const f = createFairy();
    f.position.set(Math.floor(Math.random() * 3 - 1) * state.laneWidth, 1.5, nextFairyZ);
    scene.add(f); fairies.push(f);
    nextFairyZ -= 25 + Math.random() * 35;
  }
  // Environment (flowers, mushrooms, wisps, grass)
  while (nextEnvZ > farZ) {
    for (let s of [-1, 1]) {
      const x = s * (4.5 + Math.random() * 12);
      // Flowers (spring) - reduced density
      if (Math.random() > 0.65) {
        const f = createFlower(x, nextEnvZ); scene.add(f); envObjects.push(f); flowers.push(f);
      }
      // Mushrooms (night) - reduced density
      if (Math.random() > 0.8) {
        const m = createMushroom(x + (Math.random() - 0.5) * 3, nextEnvZ - Math.random() * 3);
        scene.add(m); envObjects.push(m); mushrooms.push(m);
      }
      // Wisps - reduced density
      if (Math.random() > 0.9) {
        const w = createWisp(x, nextEnvZ - Math.random() * 5);
        scene.add(w); envObjects.push(w); wisps.push(w);
      }
      // Grass
      if (Math.random() > 0.3) {
        const gr = createGrassPatch(x + (Math.random() - 0.5) * 5, nextEnvZ - Math.random() * 3);
        scene.add(gr); envObjects.push(gr); grassPatches.push(gr);
      }
    }
    // Trees
    for (let s of [-1, 1]) {
      if (Math.random() > 0.2) {
        const tree = createTree();
        tree.position.set(s * (5 + Math.random() * 18), 0, nextEnvZ);
        scene.add(tree); trees.push(tree);
      }
    }
    nextEnvZ -= 4 + Math.random() * 4;
  }
}

function cleanup() {
  const behindZ = playerGroup.position.z + 10;
  for (const arr of [obstacles, collectibles, fairies, envObjects, trees, flowers, mushrooms, wisps, grassPatches]) {
    while (arr.length > 0 && arr[0].position.z > behindZ) {
      scene.remove(arr.shift());
    }
  }
}

// ── INPUT ───────────────────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (!state.running) return;
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.targetLane = Math.max(-1, state.targetLane - 1);
  if (e.code === 'ArrowRight' || e.code === 'KeyD') state.targetLane = Math.min(1, state.targetLane + 1);
  if (e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') doJump();
  if (e.code === 'KeyF') doAttack();
});
// ── TOUCH CONTROLS (swipe gestures) ──────────────────────────────────────
if (isMobile) {
  let swipeStartX = 0, swipeStartY = 0, swipeStartTime = 0, swipeHandled = false;
  const SWIPE_THRESHOLD = 30, SWIPE_TIME = 300, TAP_THRESHOLD = 12, TAP_TIME = 250;
  let hintTimeout = null;

  document.addEventListener('touchstart', e => {
    const t = e.target;
    if (t.closest('#start-screen') || t.closest('#game-over')) return;
    if (!state.running) return;
    swipeStartX = e.touches[0].clientX;
    swipeStartY = e.touches[0].clientY;
    swipeStartTime = Date.now();
    swipeHandled = false;
  }, { passive: true });

  document.addEventListener('touchend', e => {
    if (!state.running || swipeHandled) return;
    const t = e.target;
    if (t.closest('#start-screen') || t.closest('#game-over')) return;
    if (e.changedTouches.length === 0) return;
    const dx = e.changedTouches[0].clientX - swipeStartX;
    const dy = swipeStartY - e.changedTouches[0].clientY;
    const elapsed = Date.now() - swipeStartTime;
    const absDx = Math.abs(dx), absDy = Math.abs(dy);

    if (elapsed < SWIPE_TIME) {
      if (absDx > SWIPE_THRESHOLD && absDx > absDy) {
        // Horizontal swipe — lane change
        if (dx > 0) state.targetLane = Math.min(1, state.targetLane + 1);
        else state.targetLane = Math.max(-1, state.targetLane - 1);
        swipeHandled = true;
      } else if (dy > SWIPE_THRESHOLD && absDy > absDx) {
        // Upward swipe — jump
        doJump();
        swipeHandled = true;
      } else if (absDx < TAP_THRESHOLD && absDy < TAP_THRESHOLD && elapsed < TAP_TIME) {
        // Tap — attack
        doAttack();
        swipeHandled = true;
      }
    }
  }, { passive: true });

  // Prevent scroll/zoom during gameplay
  document.addEventListener('touchmove', e => {
    if (state.running) e.preventDefault();
  }, { passive: false });
}

function doJump() { if (!state.jumping || state.onPlatform) { state.jumping = true; state.jumpVel = state.jumpForce; state.onPlatform = null; } }
function doAttack() {
  if (!state.attacking) {
    state.attacking = true; state.attackTimer = 0.3;
    daggerGroup.visible = true;
    blade.material.emissiveIntensity = 1.0;
    triggerSlash();
    audio.playSlash();
  }
}

// ── DAY / NIGHT CYCLE ───────────────────────────────────────────────────
function updateCycle() {
  const dist = Math.abs(state.distance);
  // 300m day, 50m transition, 300m night, 50m transition = 700m full cycle
  const cycleLen = 700;
  const pos = (dist % cycleLen) / cycleLen;
  const dayLen = 300 / cycleLen, transLen = 50 / cycleLen;
  let t;
  if (pos < dayLen) t = 0;
  else if (pos < dayLen + transLen) t = (pos - dayLen) / transLen;
  else if (pos < dayLen + transLen + dayLen) t = 1;
  else t = 1 - (pos - dayLen - transLen - dayLen) / transLen;
  state.cyclePhase = t;

  // Sky/fog
  const dayFog = new THREE.Color(0x2a4a2a);
  const nightFog = new THREE.Color(0x1a1a3a);
  scene.fog.color.lerpColors(dayFog, nightFog, t);
  scene.fog.density = 0.012 - t * 0.003;

  // Ambient
  const dayAmb = new THREE.Color(0x6aaa6a);
  const nightAmb = new THREE.Color(0x6060bb);
  ambientLight.color.lerpColors(dayAmb, nightAmb, t);
  ambientLight.intensity = 1.2 + t * 0.3;

  // Directional light
  dirLight.color.lerpColors(new THREE.Color(0xffeedd), new THREE.Color(0xbbccff), t);
  dirLight.intensity = 1.6 - t * 0.3;

  renderer.toneMappingExposure = 1.8 - t * 0.2;

  // Sun rays
  for (const ray of sunRays) ray.material.opacity = (1 - t) * 0.04;

  // Aurora
  for (let i = 0; i < auroraMaterials.length; i++) {
    auroraMaterials[i].opacity = t * 0.2;
    const mesh = auroraGroup.children[i];
    const orig = mesh.userData.origPositions;
    const posAttr = mesh.geometry.attributes.position;
    const time = Date.now() * 0.001;
    for (let j = 0; j < posAttr.count; j++) {
      posAttr.array[j * 3 + 1] = orig[j * 3 + 1] + Math.sin(time * 0.5 + j * 0.3 + mesh.userData.phase) * 2;
    }
    posAttr.needsUpdate = true;
  }
  auroraGroup.position.z = state.distance - 40;

  // Mushroom emissive glow (night)
  for (const m of mushrooms) {
    const cap = m.children[0];
    if (cap && cap.material) cap.material.emissiveIntensity = 0.3 + t * 0.8;
  }
  // Wisps (brighter at night)
  for (const w of wisps) {
    w.children[0].material.opacity = 0.3 + t * 0.7;
    w.children[1].material.opacity = 0.1 + t * 0.2;
  }

  // Ground color shift
  groundMat.color.lerpColors(new THREE.Color(0x2a4a22), new THREE.Color(0x1a1a30), t);
  pathMat.color.lerpColors(new THREE.Color(0x4a3a1a), new THREE.Color(0x2a2040), t);

  // Dust particles color
  dustMat.color.lerpColors(new THREE.Color(0xffeedd), new THREE.Color(0xaaaaff), t);
  dustMat.opacity = 0.2 + t * 0.25;

  const hudItems = document.querySelectorAll('.hud-item');
  if (t < 0.3) {
    dom.cycleIndicator.textContent = '\u2727 SPRING COURT \u2727';
    dom.cycleIndicator.style.color = '#8f8';
    dom.cycleIndicator.style.borderColor = 'rgba(100,255,100,0.2)';
    dom.cycleIndicator.style.borderTopColor = 'rgba(100,200,74,0.4)';
    hudItems.forEach(el => el.style.borderTopColor = 'rgba(150,200,74,0.25)');
  } else if (t > 0.7) {
    dom.cycleIndicator.textContent = '\u263E NIGHT COURT \u263E';
    dom.cycleIndicator.style.color = '#aaf';
    dom.cycleIndicator.style.borderColor = 'rgba(150,150,255,0.3)';
    dom.cycleIndicator.style.borderTopColor = 'rgba(150,170,255,0.4)';
    hudItems.forEach(el => el.style.borderTopColor = 'rgba(150,170,255,0.3)');
  } else {
    dom.cycleIndicator.textContent = '\u2726 TWILIGHT \u2726';
    dom.cycleIndicator.style.color = '#a8a';
    dom.cycleIndicator.style.borderColor = 'rgba(170,130,170,0.2)';
    dom.cycleIndicator.style.borderTopColor = 'rgba(180,140,200,0.4)';
    hudItems.forEach(el => el.style.borderTopColor = 'rgba(180,140,200,0.25)');
  }

  // Sync touch-controls theme
  if (isMobile) {
    const tc = document.getElementById('touch-controls');
    tc.classList.remove('night', 'twilight');
    if (t > 0.7) tc.classList.add('night');
    else if (t >= 0.3) tc.classList.add('twilight');
  }

  audio.setCycle(t);
}

// ── COLLISIONS ──────────────────────────────────────────────────────────
function checkCollisions() {
  const px = playerGroup.position.x, pz = playerGroup.position.z, py = state.playerY;

  for (const obs of obstacles) {
    const dz = Math.abs(obs.position.z - pz), dx = Math.abs(obs.position.x - px);
    if (dz < 1.0 && dx < obs.userData.hitbox.w / 2 + 0.3) {
      if (obs.userData.jumpable && py >= obs.userData.hitbox.h - 0.1 && state.jumpVel <= 0) {
        // Land on top of rock
        state.playerY = obs.userData.hitbox.h;
        state.jumping = false;
        state.jumpVel = 0;
        state.onPlatform = obs;
        state.score += 15;
      } else if (py < obs.userData.hitbox.h) {
        if (state.hitCooldown <= 0) { gameOver(); return; }
      }
    }
  }
  for (const fairy of fairies) {
    if (!fairy.userData.alive) continue;
    const dz = Math.abs(fairy.position.z - pz), dx = Math.abs(fairy.position.x - px);
    if (dz < 1.2 && dx < 0.8) {
      if (state.attacking) {
        fairy.userData.alive = false;
        state.score += 50;
        shakeIntensity = Math.max(shakeIntensity, 0.02);
        spawnParticle(fairy.position.clone(), 0xaa66ff, 8);
        audio.playKill();
        scene.remove(fairy);
      } else if (state.hitCooldown <= 0) { gameOver(); return; }
    }
  }
  for (let i = collectibles.length - 1; i >= 0; i--) {
    const col = collectibles[i];
    const dz = Math.abs(col.position.z - pz), dx = Math.abs(col.position.x - px);
    if (dz < 1.2 && dx < 0.8 && Math.abs(py + 1 - col.position.y) < 1.2) {
      if (col.userData.type === 'ash') {
        state.ashShavings++;
        state.score += 10;
        state.speedBoost = Math.min(0.3, state.speedBoost + 0.015);
        shakeIntensity = Math.max(shakeIntensity, 0.015);
        spawnParticle(col.position.clone(), 0xddaa44, 10);
        dom.speedBoost.style.opacity = '1';
        dom.speedBoost.textContent = `SPEED +${Math.round(state.speedBoost * 100)}%`;
        setTimeout(() => dom.speedBoost.style.opacity = '0', 1500);
      } else {
        state.ironCharms++;
        state.score += 25;
        state.hitCooldown = 3;
        // Iron also slows beast
        state.beastDistance = Math.min(80, state.beastDistance + 8);
        shakeIntensity = Math.max(shakeIntensity, 0.02);
        spawnParticle(col.position.clone(), 0x6666ff, 10);
        dom.invincible.style.opacity = '1';
        setTimeout(() => dom.invincible.style.opacity = '0', 3000);
      }
      audio.playCollect(col.userData.type);
      scene.remove(col);
      collectibles.splice(i, 1);
    }
  }
}

// ── GAME OVER ───────────────────────────────────────────────────────────
function gameOver() {
  state.running = false;
  if (isMobile) document.getElementById('touch-controls').classList.remove('visible');
  const finalScore = state.score + Math.floor(Math.abs(state.distance)) + state.ashShavings * 5 + state.ironCharms * 10;
  dom.finalScore.textContent = finalScore.toLocaleString();
  dom.finalDistance.textContent = Math.floor(Math.abs(state.distance)) + 'm';
  dom.gameOver.style.display = 'flex';
}

// ── UPDATE ──────────────────────────────────────────────────────────────
const clock = new THREE.Clock();
let runAnim = 0;
let shakeIntensity = 0;
let prevScore = 0, prevAsh = 0, prevIron = 0;

function update() {
  const dt = Math.min(clock.getDelta(), 0.05);
  updateSlashCanvas(dt);
  if (!state.running) return;

  // Speed
  const baseNow = state.baseSpeed + Math.abs(state.distance) * 0.00008;
  state.speed = Math.min(state.maxSpeed, baseNow * (1 + state.speedBoost));

  // Forward
  state.distance -= state.speed;
  playerGroup.position.z = state.distance;

  // Lane
  playerGroup.position.x += (state.targetLane * state.laneWidth - playerGroup.position.x) * 0.15;

  // Jump
  if (state.jumping) {
    state.jumpVel -= state.gravity;
    state.playerY += state.jumpVel;
    if (state.playerY <= 0) { state.playerY = 0; state.jumping = false; }
  }
  // Platform tracking — fall off rock once player passes it
  if (state.onPlatform) {
    if (state.onPlatform.position.z > playerGroup.position.z + 1.0) {
      state.onPlatform = null;
      state.jumping = true;
      state.jumpVel = 0;
    }
  }
  playerGroup.position.y = state.playerY;

  // Blob shadow
  playerShadow.position.x = playerGroup.position.x;
  playerShadow.position.z = playerGroup.position.z;
  const shadowScale = Math.max(0.4, 1.0 - state.playerY * 0.3);
  playerShadow.scale.setScalar(shadowScale);
  playerShadow.material.opacity = shadowScale * 0.7;

  // Run animation
  runAnim += dt * state.speed * 25;
  leftLeg.rotation.x = Math.sin(runAnim) * 0.6;
  rightLeg.rotation.x = Math.sin(runAnim + Math.PI) * 0.6;
  leftArm.rotation.x = Math.sin(runAnim + Math.PI) * 0.4;
  rightArm.rotation.x = Math.sin(runAnim) * 0.4;
  body.rotation.x = Math.sin(runAnim * 2) * 0.03;
  cloak.rotation.x = 0.1 + Math.sin(runAnim) * 0.06;
  hair.rotation.x = 0.3 + Math.sin(runAnim) * 0.04;

  // Attack
  if (state.attacking) {
    state.attackTimer -= dt;
    daggerGroup.rotation.z = Math.sin(state.attackTimer * 30) * 1.5;
    blade.material.emissiveIntensity = state.attackTimer * 3;
    if (state.attackTimer <= 0) { state.attacking = false; daggerGroup.visible = false; blade.material.emissiveIntensity = 0; }
  }

  // Invincibility
  if (state.hitCooldown > 0) {
    state.hitCooldown -= dt;
    body.material.emissive.setHex(0x222266);
    body.material.emissiveIntensity = 0.3 + Math.sin(Date.now() * 0.02) * 0.2;
  } else {
    body.material.emissive.setHex(0x000000);
    body.material.emissiveIntensity = 0;
  }

  state.score += Math.floor(state.speed * 2);

  // Camera
  camera.position.x += (playerGroup.position.x * 0.3 - camera.position.x) * 0.08;
  camera.position.z = state.distance + 8;
  camera.position.y = 4.5 + state.playerY * 0.3;
  // Camera shake
  shakeIntensity *= 0.92;
  if (state.beastClosing) shakeIntensity = Math.max(shakeIntensity, 0.03 * (1 - state.beastDistance / 25));
  if (shakeIntensity > 0.001) {
    camera.position.x += (Math.random() - 0.5) * shakeIntensity * 2;
    camera.position.y += (Math.random() - 0.5) * shakeIntensity * 2;
  }
  camera.lookAt(playerGroup.position.x * 0.5, 1.5, state.distance - 10);

  // Move ground
  ground.position.z = state.distance - 200;
  pathMesh.position.z = state.distance - 200;

  // Lights follow
  magicLight.position.set(playerGroup.position.x, 3, state.distance - 5);
  dirLight.position.set(playerGroup.position.x + 5, 15, state.distance + 10);
  dirLight.target.position.set(playerGroup.position.x, 0, state.distance);

  // Dust follows
  dustParticles.position.z = state.distance;
  const dPos = dustGeo.attributes.position.array;
  for (let i = 0; i < dustCount; i++) {
    dPos[i * 3 + 1] += Math.sin(Date.now() * 0.001 + i) * 0.003;
    if (dPos[i * 3 + 1] > 5) dPos[i * 3 + 1] = 0;
  }
  dustGeo.attributes.position.needsUpdate = true;

  // Beast
  if (Math.abs(state.distance) > 100) {
    const beastSpd = state.speed * (0.85 + state.cyclePhase * 0.2);
    state.beastDistance -= (state.speed - beastSpd) * 0.25;
    state.beastDistance = Math.max(6, state.beastDistance);
    state.beastClosing = state.beastDistance < 25;
  }
  beastGroup.position.z = state.distance + state.beastDistance;
  beastGroup.position.x += (playerGroup.position.x - beastGroup.position.x) * 0.015;
  const bTime = Date.now() * 0.001;
  beastBody.rotation.y = Math.sin(bTime * 3) * 0.2;
  beastBody.scale.y = 0.7 + Math.sin(bTime * 1.5) * 0.05;
  for (const t of beastTendrils) {
    t.rotation.x = t.userData.baseRotX + Math.sin(bTime + t.userData.phaseX) * 0.4;
    t.rotation.z = t.userData.baseRotZ + Math.sin(bTime * 0.8 + t.userData.phaseZ) * 0.3;
  }
  const eyeScale = 1.0 + (state.beastClosing ? Math.sin(bTime * 4) * 0.15 : 0);
  for (const e of beastEyes) { e.scale.y = 0.7 * eyeScale; }
  beastSmoke.material.opacity = 0.4 + Math.sin(bTime) * 0.2;
  beastLight.intensity = 0.5 + (state.beastClosing ? Math.sin(Date.now() * 0.01) * 0.8 : 0);
  audio.setHuntIntensity(state.beastClosing ? Math.max(0, 1 - state.beastDistance / 25) : 0);

  dom.beastWarning.classList.toggle('active', state.beastClosing);
  if (state.beastDistance <= 6) { gameOver(); return; }

  // Collectible animation
  for (const col of collectibles) {
    col.rotation.y += dt * (col.userData.rotSpeed || 2);
    col.position.y = 1.0 + Math.sin(Date.now() * 0.003 + col.position.z) * 0.2;
  }
  // Fairy animation
  for (const f of fairies) {
    if (f.userData.alive) {
      f.position.y = 1.5 + Math.sin(Date.now() * 0.004 + f.userData.bobPhase) * 0.4;
      f.rotation.y += dt * 2;
    }
  }
  // Wisps float
  for (const w of wisps) {
    w.position.y = w.userData.baseY + Math.sin(Date.now() * 0.002 * w.userData.speed + w.userData.phase) * 0.5;
    w.position.x = w.userData.baseX + Math.sin(Date.now() * 0.001 + w.userData.phase) * 1.5;
  }
  // Grass wind
  for (const gp of grassPatches) {
    for (const blade of gp.children) {
      blade.rotation.x = blade.userData.baseRotX + Math.sin(Date.now() * 0.002 + gp.position.z * 0.1) * 0.15;
    }
  }
  // Flower bob (skip per-frame filter)
  // Flowers animate via their group position, not individual petals

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.userData.life -= dt * 2.5;
    p.position.add(p.userData.vel);
    p.userData.vel.y -= 0.004;
    p.material.opacity = Math.max(0, p.userData.life);
    p.scale.setScalar(p.userData.life);
    if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
  }

  // Trail particles
  trailTimer += dt;
  if (state.speed > 0.4 && trailTimer >= 0.06) {
    trailTimer = 0;
    const tp = trailPool[trailIdx];
    tp.position.set(playerGroup.position.x + (Math.random() - 0.5) * 0.3, 0.05, playerGroup.position.z + 0.5);
    tp.userData.life = 1;
    tp.visible = true;
    tp.material.opacity = 0.5;
    tp.scale.setScalar(1);
    trailIdx = (trailIdx + 1) % trailPool.length;
  }
  for (const tp of trailPool) {
    if (tp.userData.life > 0) {
      tp.userData.life -= dt * 3;
      tp.material.opacity = tp.userData.life * 0.5;
      tp.scale.setScalar(tp.userData.life);
      if (tp.userData.life <= 0) tp.visible = false;
    }
  }

  updateCycle();
  spawnObjects();
  cleanup();
  checkCollisions();

  // HUD
  dom.scoreVal.textContent = state.score.toLocaleString();
  dom.distVal.textContent = Math.floor(Math.abs(state.distance)) + 'm';
  dom.ashVal.textContent = state.ashShavings;
  dom.ironVal.textContent = state.ironCharms;
  // HUD pop animation
  if (state.ashShavings !== prevAsh) {
    prevAsh = state.ashShavings;
    dom.ashVal.classList.add('pop');
    setTimeout(() => dom.ashVal.classList.remove('pop'), 200);
  }
  if (state.ironCharms !== prevIron) {
    prevIron = state.ironCharms;
    dom.ironVal.classList.add('pop');
    setTimeout(() => dom.ironVal.classList.remove('pop'), 200);
  }
  if (state.score - prevScore >= 20) {
    prevScore = state.score;
    dom.scoreVal.classList.add('pop');
    setTimeout(() => dom.scoreVal.classList.remove('pop'), 200);
  }
}

// ── RENDER LOOP ─────────────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}
animate();

// ── START / RESTART ─────────────────────────────────────────────────────
function startGame() {
  audio.init();
  Object.assign(state, {
    running: true, speed: state.baseSpeed, distance: 0, score: 0,
    ashShavings: 0, ironCharms: 0, speedBoost: 0,
    lane: 0, targetLane: 0, jumping: false, jumpVel: 0, playerY: 0,
    beastDistance: 80, beastClosing: false, attacking: false, hitCooldown: 0, cyclePhase: 0, onPlatform: null,
  });
  playerGroup.position.set(0, 0, 0);
  beastGroup.position.set(0, 0, 80);
  nextObsZ = -30; nextColZ = -20; nextFairyZ = -50; nextEnvZ = -5;
  for (const arr of [obstacles, collectibles, fairies, particles, envObjects, trees, flowers, mushrooms, wisps, grassPatches]) {
    while (arr.length) scene.remove(arr.pop());
  }
  slashTrails = [];
  shakeIntensity = 0;
  prevScore = 0; prevAsh = 0; prevIron = 0;
  trailIdx = 0; trailTimer = 0;
  for (const tp of trailPool) { tp.visible = false; tp.userData.life = 0; }
  dom.startScreen.style.display = 'none';
  dom.gameOver.style.display = 'none';
  if (isMobile) {
    document.getElementById('touch-controls').classList.add('visible');
    const sh = document.getElementById('swipe-hint');
    if (sh) { sh.classList.remove('fade'); setTimeout(() => sh.classList.add('fade'), 4000); }
  }
  dom.speedBoost.style.opacity = '0';
  dom.invincible.style.opacity = '0';
  clock.getDelta();
}

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  resizeSlash();
});
</script>
</body>
</html>
